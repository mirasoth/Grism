# RFC-0008: Physical Plan & Operator Interfaces

**Status**: Draft
**Authors**: HyperGraph / Grism Team
**Last Updated**: 2026-01-21
**Depends on**: RFC-0002, RFC-0003, RFC-0006, RFC-0007
**Supersedes**: —

---

## 1. Abstract

This RFC defines the **physical plan representation** and **operator interfaces** for HyperGraph.

A physical plan is a *fully executable*, mode-specific realization of a logical plan. This document specifies:

* Physical plan structure and invariants
* Operator interface contracts
* Execution lifecycle and data model
* Mode-specific operator requirements
* Extension and backend compatibility rules

This RFC is the **boundary of trust** between planners and execution engines.

---

## 2. Scope and Non-Goals

### 2.1 Scope

This RFC specifies:

* Physical plan node structure
* Operator input/output contracts
* Execution context and lifecycle
* Operator capabilities and constraints
* Error and cancellation semantics

### 2.2 Non-Goals

This RFC does **not** define:

* Concrete algorithms (hash join vs merge join)
* Threading or scheduling policies
* Memory layout optimizations
* Distributed orchestration (future RFC)
* Storage engine internals

---

## 3. Design Principles

1. **Planner–Executor Decoupling**
   Planners emit *what to do*, executors decide *how*.

2. **Columnar First, Graph Aware**
   All operators operate on columnar data, even in graph mode.

3. **Composable Operators**
   Operators MUST be pipelineable unless explicitly blocking.

4. **Capability Discovery**
   Executors declare supported operator capabilities.

---

## 4. Physical Plan Model

### 4.1 Physical Plan Definition

A **Physical Plan** is a DAG of **Physical Operators**.

Properties:

* Fully resolved execution mode
* No logical-only operators remain
* All expressions are executable
* All resources are bound or bindable

---

### 4.2 Physical Plan Invariants

A valid physical plan MUST satisfy:

1. **Semantic Equivalence**
   Equivalent to its logical plan (RFC-0002).

2. **Mode Consistency**
   All operators are compatible with the selected execution mode.

3. **Executable Expressions**
   All expressions have runtime implementations.

4. **Determinism Preservation**
   Volatile expressions are explicitly marked.

---

## 5. Execution Context

### 5.1 ExecutionContext

Every operator executes within an `ExecutionContext` providing:

* Execution mode
* Runtime configuration
* Statistics hooks
* Cancellation token
* Memory accounting interface

The context is **read-only** to operators.

---

### 5.2 Operator Lifecycle

Each operator follows a strict lifecycle:

```
create → open → next* → close
```

Rules:

* `open()` initializes resources
* `next()` produces zero or more batches
* `close()` MUST be idempotent
* Errors abort the pipeline

---

## 6. Data Model

### 6.1 Batch-Oriented Execution

Operators exchange **DataBatches**:

```
DataBatch {
  columns: Vec<Column>
  row_count: usize
  schema: PhysicalSchema
}
```

Rules:

* Columnar layout is mandatory
* Row ordering is undefined unless specified
* Batches may be empty (termination signal)

---

### 6.2 PhysicalSchema

Includes:

* Column name
* Physical type
* Nullability
* Role / label metadata (graph mode)

Schemas MUST be stable across operator boundaries.

---

## 7. Physical Operator Interface

### 7.1 Base Operator Trait (Normative)

Conceptual interface:

```
PhysicalOperator {
  fn open(ctx)
  fn next() -> DataBatch | End
  fn close()
  fn schema() -> PhysicalSchema
  fn capabilities() -> OperatorCaps
}
```

Operators MUST NOT:

* Mutate upstream data
* Perform side effects outside context
* Block indefinitely without yielding

---

### 7.2 Operator Categories

| Category | Blocking | Examples             |
| -------- | -------- | -------------------- |
| Source   | No       | Scan                 |
| Unary    | No       | Filter, Project      |
| Binary   | No       | Join                 |
| Expand   | No       | AdjacencyExpand      |
| Blocking | Yes      | Aggregate, Sort      |
| Sink     | Yes      | Collect, Materialize |

Blocking operators MUST explicitly declare blocking behavior.

---

## 8. Core Physical Operators

### 8.1 Scan

Reads base data.

Variants:

* TableScan
* NodeScan
* EdgeScan
* HyperEdgeScan

Scan MUST expose:

* Predicate pushdown capability
* Projection pushdown capability

---

### 8.2 Filter

Applies predicate expressions.

Rules:

* Three-valued logic preserved
* Short-circuiting optional
* Vector predicates allowed

---

### 8.3 Project

Evaluates expression list.

Rules:

* No column reordering unless specified
* Expression failures abort batch

---

### 8.4 Expand (Graph-Native)

Traverses adjacency.

Variants:

* Node → Edge
* Edge → Node
* HyperEdge → Role

Rules:

* Fan-out may change row count
* Role binding MUST be explicit
* Directionality MUST be respected

Expand is the **semantic anchor** of graph execution.

---

### 8.5 Join

Combines two inputs.

Rules:

* Only inner joins guaranteed
* Join condition MUST be executable expression
* Join strategy is executor-defined

---

### 8.6 Aggregate

Consumes entire input.

Rules:

* Blocking operator
* Group keys MUST be explicit
* Aggregates follow RFC-0003 semantics

---

### 8.7 Limit

Limits number of rows.

Rules:

* Early termination allowed
* Non-blocking

---

## 9. Mode-Specific Requirements

### 9.1 Relational Mode

* Expand MUST be compiled away or emulated
* Joins dominate
* Adjacency metadata optional

---

### 9.2 Graph Mode

* Expand MUST be native
* Adjacency indexes REQUIRED
* Joins discouraged

---

### 9.3 Hybrid Mode

* Mixed operators allowed
* Expand + Join fusion permitted
* Mode transitions MUST be explicit

---

## 10. Operator Capabilities

Operators declare capabilities such as:

* Predicate pushdown
* Projection pushdown
* Vector acceleration
* Adjacency awareness
* Streaming support

Planners MAY adapt physical plans based on capabilities.

---

## 11. Error & Cancellation Semantics

### 11.1 Errors

Errors MUST:

* Abort downstream operators
* Release resources
* Surface diagnostic information

Partial results MUST NOT be returned.

---

### 11.2 Cancellation

* Operators MUST periodically check cancellation token
* Cancellation is cooperative
* Best-effort cleanup required

---

## 12. Extension & Custom Operators

New operators MUST:

* Declare category and blocking behavior
* Define schema transformation
* Respect execution mode constraints

Experimental operators MUST be explicitly flagged.

---

## 13. Explainability & Debugging

Executors MUST support:

* Operator-level timing
* Row counts in/out
* Memory usage
* Execution mode trace

These are **mandatory for EXPLAIN ANALYZE**.

---

## 14. Relationship to Other RFCs

* **RFC-0002**: Logical operator semantics
* **RFC-0003**: Expression execution
* **RFC-0006**: Rewrite legality
* **RFC-0007**: Mode selection feeds into physical planning
* **RFC-0010**: Distributed execution (future)

RFC-0008 is the **executor contract**.

---

## 15. Open Questions

* Vectorized vs row-wise execution fallback
* Spill-to-disk interfaces
* Asynchronous operators
* GPU / accelerator integration

---

## 16. Conclusion

This RFC defines **what it means to execute a query** in HyperGraph.

> **Logical plans define meaning.
> Physical plans define reality.
> RFC-0008 defines the border between them.**
