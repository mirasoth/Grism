# RFC-0018: Persistent Storage & Adjacency Layout

**Status**: Draft
**Authors**: Grism Team
**Created**: 2026-01-23
**Last Updated**: 2026-01-23
**Depends on**: RFC-0008, RFC-0009, RFC-0012, RFC-0102
**Supersedes**: —

---

## 1. Abstract

This RFC defines the **persistent storage layout** for Grism, covering:

* Node persistence
* Hyperedge persistence
* Adjacency persistence as a first-class, topology-oriented layout

The goal of this RFC is to formalize how logical graph entities are *physically materialized* on persistent storage, while remaining fully consistent with:

* The storage abstraction and snapshot semantics defined in RFC-0012
* The adjacency and access-path model defined in RFC-0009
* The execution and operator contracts defined in RFC-0008 and RFC-0102

This RFC specifies **what is stored and how it is structured**, not how it is executed or accessed at runtime.

---

## 2. Scope and Non-Goals

### 2.1 Scope

This RFC specifies:

* Persistent layout of nodes
* Persistent layout of hyperedges
* Persistent layout of adjacency structures
* Metadata contracts required for planner discovery and execution binding

### 2.2 Non-Goals

This RFC does **not** define:

* Physical execution algorithms
* In-memory data structures
* Index maintenance or update protocols
* Transaction or write semantics
* Query language bindings

---

## 3. Design Principles

### 3.1 Storage Is Semantically Neutral

Persistent layouts MUST NOT alter logical semantics.

They MAY:

* Accelerate access paths
* Constrain physical planning choices
* Improve locality and traversal performance

They MUST NOT:

* Implicitly filter data
* Impose ordering unless explicitly declared
* Encode execution-specific assumptions

---

### 3.2 Adjacency Is a First-Class Persistent Concept

Adjacency is not derived implicitly from entity storage.

Adjacency MUST:

* Be explicitly materialized
* Declare its guarantees
* Be independently fragmentable
* Be discoverable by the planner

Adjacency is a **persistent topology accelerator**, not a logical operator.

---

### 3.3 Snapshot Consistency

All persistent layouts MUST:

* Be immutable within a `SnapshotId`
* Be stable across execution runtimes
* Observe snapshot isolation as defined in RFC-0012

---

## 4. Persistent Entity Storage

### 4.1 Node Storage Layout

Nodes are stored in **columnar datasets**, grouped by label.

```
Dataset: Node::<Label>
├── node_id : NodeId
├── property_col_1
├── property_col_2
├── ...
└── metadata
```

#### Properties

* Columnar (Arrow/Lance-compatible)
* Fragmented into immutable `Fragment`s
* Scannable via `Storage::scan()`

Nodes do **not** embed adjacency information.

---

### 4.2 Hyperedge Storage Layout

Hyperedges are stored as first-class entities.

```
Dataset: Hyperedge::<Label>
├── edge_id : EdgeId
├── arity : usize
├── role_descriptor
├── property_col_1
├── property_col_2
└── metadata
```

#### Properties

* Hyperedges are independent of adjacency layout
* Role information is logically preserved
* Hyperedge datasets are scannable like nodes

Hyperedge storage does not imply traversal semantics.

---

## 5. Persistent Adjacency Storage

### 5.1 Adjacency as a Persistent Dataset

Adjacency is materialized as **dedicated persistent datasets**, independent of node and hyperedge storage.

Each adjacency dataset represents a *logical adjacency specification* with declared guarantees.

```
Dataset: Adjacency::<EdgeLabel>::<AdjacencySpec>
```

Adjacency datasets MAY exist in multiple variants (e.g., directional, role-projected).

---

### 5.2 Adjacency Fragment Layout

Adjacency datasets are fragmented into immutable adjacency fragments.

Conceptual layout:

```
AdjacencyFragment
├── anchor_id : NodeId
├── offsets[anchor_id] → range
├── neighbor_id[]
├── edge_id[]
└── optional role metadata
```

This layout is topology-oriented and optimized for traversal.

---

### 5.3 AdjacencyFragmentMeta

Each adjacency fragment MUST be described by metadata discoverable by the planner.

```rust
struct AdjacencyFragmentMeta {
    fragment_id: FragmentId,
    snapshot: SnapshotId,

    adjacency: AdjacencySpec,

    anchor_entity: EntityType,
    target_entity: EntityType,

    direction: AdjacencyDirection,
    role_spec: RoleSpec,
    arity: AritySpec,

    stats: Option<AdjacencyStats>,
    caps: AdjacencyCaps,
}
```

This metadata is **purely descriptive** and contains no execution logic.

---

## 6. Adjacency Semantics

### 6.1 Directionality

Adjacency MUST explicitly declare directionality:

```
Outbound | Inbound | Undirected
```

Direction is a guarantee, not a query hint.

---

### 6.2 Role Semantics

Adjacency MUST declare its role semantics:

* **Binary**: Fixed source → target roles
* **Role-Aware**: One anchor role, multiple target roles
* **Full-Arity**: Hyperedge participants preserved

Role semantics determine eligibility for Expand operators.

---

### 6.3 Arity Guarantees

Adjacency MUST declare supported arity:

* `Binary`
* `Bounded { max }`
* `Arbitrary`

Planners MUST NOT assume stronger guarantees than declared.

---

## 7. Planner Visibility and Binding

### 7.1 Discovery

Storage backends MUST expose adjacency fragment metadata in a deterministic manner.

Planners MAY inspect:

* Available adjacency datasets
* Fragment-level guarantees
* Role and arity constraints

---

### 7.2 Execution Binding

Adjacency layouts are bound during **physical planning**.

Execution accesses adjacency **only** through:

* Physical Expand operators
* `ExecutionContextTrait::storage()`

Execution MUST NOT inspect adjacency layout directly.

---

## 8. Relationship to Access Paths

Adjacency persistence directly enables adjacency access paths as defined in RFC-0009.

Important invariants:

* Adjacency is an access path, not an operator
* Persistent adjacency does not imply mandatory usage
* Logical plans remain adjacency-agnostic

---

## 9. Backend Independence

This RFC does not mandate a specific storage backend.

Valid implementations include:

* Lance-based local filesystems
* In-memory test backends
* Cloud object stores (S3, GCS, etc.)

All backends MUST honor the same metadata and snapshot contracts.

---

## 10. Guarantees

This RFC guarantees:

1. Persistent layouts are semantically neutral
2. Adjacency is explicitly and safely materialized
3. Storage remains execution-agnostic
4. Planner decisions are fully explainable
5. Local and distributed runtimes observe identical semantics

---

## 11. Relationship to Other RFCs

* **RFC-0012**: Defines storage abstractions and snapshot semantics
* **RFC-0009**: Defines adjacency and access path guarantees
* **RFC-0008**: Defines physical operators that bind adjacency
* **RFC-0102**: Defines execution architecture and runtime behavior

RFC-0018 defines **how graph topology is persisted**, not how it is executed.

---

## 12. Summary

Persistent storage in Grism is built on a clear separation:

* **Entities** store data
* **Adjacency** stores topology
* **Metadata** binds storage to planning

By materializing adjacency explicitly while preserving execution neutrality, Grism achieves:

* High-performance traversal
* Strong semantic guarantees
* Long-term architectural extensibility

This RFC completes the persistent foundation required for graph-native execution in Grism.
