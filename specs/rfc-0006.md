# RFC-0006: Logical Planning & Rewrite Rules

**Status**: Draft
**Authors**: HyperFrame / Grism Team
**Last Updated**: 2026-01-21
**Depends on**: RFC-0002, RFC-0003
**Supersedes**: —

---

## 1. Abstract

This RFC specifies the **logical planning phase** of HyperFrame and defines the **rewrite rules** that may be applied to a logical plan.

Logical planning is responsible for transforming a *semantically correct* plan into an *equivalent but structurally improved* plan, without changing meaning. This RFC defines the **safety envelope** within which all optimizations MUST operate.

No optimization may violate the semantics defined in RFC-0002 or the expression semantics defined in RFC-0003.

---

## 2. Scope and Non-Goals

### 2.1 Scope

This RFC defines:

* Logical plan structure and invariants
* Rewrite rule categories
* Formal safety conditions for rewrites
* Rewrite legality and equivalence guarantees
* Interaction between rewrites and execution modes

### 2.2 Non-Goals

This RFC does **not** define:

* Cost models or statistics (RFC-0007)
* Physical execution plans
* Index selection
* Distribution strategies
* Language parsing or syntax

---

## 3. Logical Plan Model

### 3.1 Plan Definition

A **Logical Plan** is a **directed acyclic graph (DAG)** of logical operators as defined in RFC-0002.

Properties:

* Nodes are operators
* Edges represent dataflow
* Plan MUST be acyclic
* Plan MUST be closed (all inputs resolved)

---

### 3.2 Plan Invariants

A valid logical plan MUST satisfy:

1. **Semantic correctness**
   The plan corresponds to a valid HyperFrame algebra expression.

2. **Scope consistency**
   All column references are resolvable at every node.

3. **Type consistency**
   All expressions are well-typed (RFC-0003).

4. **Determinism preservation**
   No rewrite may introduce non-determinism.

---

## 4. Planning Phases

Logical planning proceeds in **ordered phases**.

```
Parsed AST
  → Canonical Logical Plan
    → Validation
      → Rewrite Phase
        → Execution Planning (out of scope)
```

Only the **Rewrite Phase** is defined by this RFC.

---

## 5. Rewrite Rule Framework

### 5.1 Rewrite Definition

A **rewrite rule** is a transformation:

```
Plan A  ⇒  Plan B
```

Such that:

* `A` and `B` are semantically equivalent
* `B` is preferred by at least one objective (e.g. fewer operators, better locality)

---

### 5.2 Rewrite Safety Conditions

A rewrite is **legal** if and only if all of the following hold:

1. **Hyperedge Preservation**
   The multiset of logical hyperedges produced is identical.

2. **Column Semantics Preservation**
   Column values are identical for all rows.

3. **NULL Semantics Preservation**
   Three-valued logic behavior is unchanged.

4. **Determinism Preservation**
   No volatile expressions are reordered across boundaries.

5. **Scope Preservation**
   No column or role shadowing is introduced.

---

## 6. Rewrite Rule Categories

### 6.1 Predicate Pushdown

**Description**
Move `Filter` operators as close as possible to data sources.

**Legal When**

* Predicate references only columns available below
* Predicate is deterministic
* Predicate does not depend on aggregation output

**Example**

```
Filter(p)
  └─ Expand
       └─ Scan
```

⇒

```
Expand
  └─ Filter(p)
       └─ Scan
```

---

### 6.2 Projection Pruning

**Description**
Remove unused columns early.

**Legal When**

* Dropped columns are not referenced downstream
* Dropped columns are not required for identity preservation

---

### 6.3 Expand Reordering

**Description**
Reorder independent `Expand` operators.

**Legal When**

* Expansions are independent
* No shared role binding
* No directional dependency

Expand reordering MUST NOT change traversal semantics.

---

### 6.4 Join Reordering

**Description**
Change join order for associative joins.

**Legal When**

* Join conditions are equi-joins
* No outer-join semantics involved
* No NULL-sensitive predicates are crossed

---

### 6.5 Join Elision

**Description**
Replace a `Join` with `Expand` when semantics allow.

**Legal When**

* Join condition corresponds to adjacency semantics
* Hyperedge arity is preserved
* No hyperedge-level predicates are present

Join elision is **optional** and correctness-preserving.

---

### 6.6 Filter–Expand Fusion

**Description**
Fuse traversal predicates into expansion constraints.

**Legal When**

* Predicate refers only to newly expanded roles
* Predicate is deterministic
* Predicate does not require post-join context

---

### 6.7 Constant Folding

**Description**
Evaluate constant expressions at plan time.

**Legal When**

* Expression is fully literal
* Expression is deterministic

---

### 6.8 Limit Pushdown

**Description**
Move `Limit` operators upstream.

**Legal When**

* No aggregation above the limit
* No ordering dependency
* Limit does not change result set semantics

---

## 7. Rewrite Ordering Constraints

Rewrite rules MUST be applied in a **semantically safe order**:

1. Validation
2. Constant folding
3. Predicate pushdown
4. Projection pruning
5. Expand / Join rewrites
6. Limit pushdown

Repeated application is allowed until a fixpoint is reached.

---

## 8. Rewrite Termination & Fixpoint

* Rewrite process MUST terminate
* Cyclic rewrites are forbidden
* Plans MUST be hashable to detect fixpoints

Rewrite engines SHOULD implement:

* Rule prioritization
* Rewrite budgets

---

## 9. Execution Mode Annotations

Logical plans MAY be annotated with **execution hints**:

* `interactive`
* `relational`
* `graph`

Rules:

* Hints MUST NOT alter semantics
* Hints MAY restrict rewrite choices
* Final execution mode selection is defined in RFC-0007

---

## 10. Explainability Requirements

Planners MUST support:

* Pre-rewrite plan
* Post-rewrite plan
* Rule-by-rule rewrite trace

This is a **mandatory requirement**, not a debugging convenience.

---

## 11. Error Handling

Rewrite-time errors include:

| Error            | Cause                          |
| ---------------- | ------------------------------ |
| IllegalRewrite   | Safety condition violated      |
| AmbiguousRewrite | Multiple incompatible rewrites |
| NonTermination   | Rewrite loop detected          |

Errors MUST surface before execution.

---

## 12. Relationship to Other RFCs

* **RFC-0002**: Defines operator semantics preserved by rewrites
* **RFC-0003**: Defines expression determinism and type safety
* **RFC-0007**: Uses rewrite output for cost-based selection
* **RFC-0009**: Relies on rewrite decisions for adjacency use

This RFC defines *what is allowed*, not *what is optimal*.

---

## 13. Open Questions

* Formal equivalence proofs for Expand ↔ Join
* Rewrite interaction with probabilistic expressions
* Rule conflict resolution strategies

---

## 14. Conclusion

This RFC defines the **semantic firewall** between meaning and optimization.

> **Optimizers may be clever.
> They may never be creative.**
