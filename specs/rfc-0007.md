# RFC-0007: Cost Model & Execution Mode Selection

**Status**: Draft
**Authors**: Grism Team
**Created**: 2026-01-21
**Last Updated**: 2026-01-21
**Depends on**: RFC-0002, RFC-0003, RFC-0006
**Supersedes**: —

---

## 1. Abstract

This RFC defines the **cost model** and **execution mode selection framework** for Hypergraph.

The cost model estimates relative execution costs of *logically equivalent* plans produced by RFC-0006 rewrites and selects an appropriate **execution mode** (relational, graph, or hybrid). The model prioritizes **predictability, explainability, and monotonicity** over perfect accuracy.

The goal is not to find the globally optimal plan, but to **avoid pathological plans** and to **choose a semantically appropriate execution strategy**.

---

## 2. Scope and Non-Goals

### 2.1 Scope

This RFC defines:

* Logical cost units and metrics
* Cost estimation inputs
* Execution modes and their semantics
* Mode eligibility and selection rules
* Explainable cost comparison

### 2.2 Non-Goals

This RFC does **not** define:

* Physical operator implementations
* Runtime adaptive re-optimization
* Distributed scheduling
* Memory management or spill behavior
* Hardware-aware optimization

---

## 3. Design Principles

1. **Explainability over optimality**
   Every cost decision MUST be explainable.

2. **Monotonic heuristics**
   Costs should increase monotonically with data size and complexity.

3. **Mode-aware planning**
   Not all plans are meaningful in all execution modes.

4. **Rewrite separation**
   Cost model evaluates plans; it does not rewrite semantics.

---

## 4. Execution Modes

Hypergraph supports multiple **execution backends** as defined in the architecture (Section 9).

### 4.1 LocalExecutor (Relational)

**Characteristics**

* Columnar execution using Arrow RecordBatch
* Batch-oriented processing
* Strong at filters, relational operations, aggregations

**Preferred When**

* Query is projection / filter / aggregation heavy
* Graph traversals are shallow or can use adjacency
* High selectivity predicates exist

---

### 4.2 LocalExecutor (Adjacency)

**Characteristics**

* Adjacency-driven execution via indexes
* Pointer-heavy traversal for binary hyperedges
* Role- and topology-aware

**Preferred When**

* Multi-hop traversals dominate
* Binary adjacency can be used (arity = 2)
* Pattern matching is primary

---

### 4.3 RayExecutor (Distributed)

**Characteristics**

* Distributed execution across Ray workers
* Rust workers perform actual query execution
* Shuffle-aware planning for large-scale workloads

**Preferred When**

* Large datasets requiring scale-out
* Complex aggregations across partitions
* Graph algorithms requiring message passing

### 4.4 Hybrid Strategy

**Characteristics**

* Multiple execution strategies within single query
* Expand operators may use different backends
* Cost-driven strategy selection per subplan

**Preferred When**

* Mixed workloads
* Early graph pruning with later aggregation
* AI / vector predicates combined with topology

Hybrid strategy is the **default** unless strongly contraindicated.

---

## 5. Cost Model Overview

Each logical plan is assigned a **cost vector**, not a single scalar.

```
Cost = {
  row_cost,
  edge_cost,
  expand_cost,
  compute_cost,
  memory_cost
}
```

Comparison is **lexicographic with weights**, not absolute.

---

## 6. Cost Inputs

### 6.1 Logical Statistics

Optional but recommended:

* Estimated row counts
* Estimated edge counts
* Label / role cardinalities
* Histogram-like selectivity estimates

Statistics MAY be:

* Collected offline
* Approximated
* Missing (fallback applies)

---

### 6.2 Operator Intrinsics

Each logical operator has a **base cost model**:

| Operator  | Dominant Cost          |
| --------- | ---------------------- |
| Scan      | row_cost               |
| Filter    | compute_cost           |
| Project   | compute_cost           |
| Expand    | edge_cost              |
| Aggregate | memory_cost            |
| Limit     | negligible             |

**Important**: There is no Join operator in the logical model. Relational composition is handled via Expand.

---

### 6.3 Expression Cost

Expressions contribute to:

* `compute_cost`
* potential vector distance costs
* non-determinism penalties

From RFC-0003:

* Deterministic scalar functions: low
* Vector similarity: high
* Volatile functions: disallowed for costing

---

## 7. Expand & Adjacency Cost Model

Expand is the **distinguishing cost center**.

Cost factors:

* Fan-out (expected degree)
* Directionality
* Role constraints
* Predicate selectivity

Approximate model:

```
expand_cost ≈ input_rows × avg_degree × selectivity
```

Adjacency-backed expands receive a **cost discount**.

---

---

## 8. Backend Eligibility Rules

A plan is **eligible** for an execution backend iff:

### 8.1 LocalExecutor (Relational) Eligibility

* Complex relational operations dominate
* Expand operators can use adjacency optimization
* No distributed requirements

### 8.2 LocalExecutor (Adjacency) Eligibility

* Expand operators with binary hyperedges dominate
* High fan-out traversals required
* No complex aggregations blocking traversal

### 8.3 RayExecutor Eligibility

* Large datasets requiring scale-out
* Cross-partition operations needed
* Graph algorithms or complex aggregations

### 8.4 Hybrid Strategy Eligibility

* Always eligible unless explicitly forbidden
* Required when mixed operation types exist

---

## 9. Backend Selection

### 9.1 Selection Algorithm (Normative)

1. Enumerate eligible backends
2. Estimate cost vector per backend
3. Apply backend-specific penalties
4. Select lowest weighted cost

---

### 9.2 Penalty Factors

| Situation                            | Penalty          |
| ------------------------------------ | ---------------- |
| Missing statistics                   | +uncertainty     |
| High fan-out Expand in relational    | +expand_penalty  |
| Large aggregation in graph mode      | +memory_penalty  |
| Vector similarity in graph-only plan | +compute_penalty |

Penalties MUST be explicit and explainable.

---

## 10. Fallback & Safety Rules

* If all costs exceed threshold → Hybrid strategy
* If statistics are missing → Conservative estimates
* If backends tie → Prefer Hybrid → RayExecutor → LocalExecutor

No query may fail solely due to cost estimation uncertainty.

---

## 11. Explainability & EXPLAIN Output

The system MUST support:

* Per-operator cost breakdown
* Mode eligibility explanation
* Penalty justification
* Final mode decision rationale

Example:

```
Chosen Mode: Hybrid
Reason:
  - Expand present (+graph)
  - Aggregation downstream (+relational)
  - Estimated fan-out low
```

---

## 12. Relationship to Rewrite Rules

* RFC-0006 rewrites generate candidates
* RFC-0007 scores candidates
* No rewrite rule may depend on cost feedback

This separation is **mandatory**.

---

## 13. Error Handling

Cost-related errors:

| Error             | Meaning                 |
| ----------------- | ----------------------- |
| NoEligibleMode    | Logical plan invalid    |
| CostOverflow      | Estimate exceeds bounds |
| InconsistentStats | Statistics conflict     |

Errors MUST degrade gracefully.

---

## 14. Open Questions

* Adaptive runtime feedback loops
* Learning-based cost models
* Multi-objective optimization (latency vs cost)
* Distributed execution costing

---

## 15. Conclusion

This RFC defines **how Hypergraph decides “how to run” a query**—without compromising correctness or transparency.

> **Rewrite rules preserve meaning.
> Cost models preserve execution sanity.**
