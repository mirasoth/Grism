# RFC-0007: Cost Model & Execution Mode Selection

**Status**: Draft
**Authors**: HyperFrame / Grism Team
**Last Updated**: 2026-01-21
**Depends on**: RFC-0002, RFC-0003, RFC-0006
**Supersedes**: —

---

## 1. Abstract

This RFC defines the **cost model** and **execution mode selection framework** for HyperFrame.

The cost model estimates relative execution costs of *logically equivalent* plans produced by RFC-0006 rewrites and selects an appropriate **execution mode** (relational, graph, or hybrid). The model prioritizes **predictability, explainability, and monotonicity** over perfect accuracy.

The goal is not to find the globally optimal plan, but to **avoid pathological plans** and to **choose a semantically appropriate execution strategy**.

---

## 2. Scope and Non-Goals

### 2.1 Scope

This RFC defines:

* Logical cost units and metrics
* Cost estimation inputs
* Execution modes and their semantics
* Mode eligibility and selection rules
* Explainable cost comparison

### 2.2 Non-Goals

This RFC does **not** define:

* Physical operator implementations
* Runtime adaptive re-optimization
* Distributed scheduling
* Memory management or spill behavior
* Hardware-aware optimization

---

## 3. Design Principles

1. **Explainability over optimality**
   Every cost decision MUST be explainable.

2. **Monotonic heuristics**
   Costs should increase monotonically with data size and complexity.

3. **Mode-aware planning**
   Not all plans are meaningful in all execution modes.

4. **Rewrite separation**
   Cost model evaluates plans; it does not rewrite semantics.

---

## 4. Execution Modes

HyperFrame supports multiple **execution modes**.

### 4.1 Relational Mode

**Characteristics**

* Columnar execution
* Batch-oriented
* Strong at filters, joins, aggregations

**Preferred When**

* Query is projection / filter / aggregation heavy
* Graph traversals are shallow
* High selectivity predicates exist

---

### 4.2 Graph Mode

**Characteristics**

* Adjacency-driven execution
* Pointer-heavy traversal
* Role- and topology-aware

**Preferred When**

* Multi-hop traversals dominate
* Adjacency constraints are explicit
* Pattern matching is primary

---

### 4.3 Hybrid Mode

**Characteristics**

* Relational backbone with graph-native operators
* Expand / adjacency as first-class operators

**Preferred When**

* Mixed workloads
* Early graph pruning with later aggregation
* AI / vector predicates combined with topology

Hybrid mode is the **default** unless strongly contraindicated.

---

## 5. Cost Model Overview

Each logical plan is assigned a **cost vector**, not a single scalar.

```
Cost = {
  row_cost,
  edge_cost,
  expand_cost,
  compute_cost,
  memory_cost
}
```

Comparison is **lexicographic with weights**, not absolute.

---

## 6. Cost Inputs

### 6.1 Logical Statistics

Optional but recommended:

* Estimated row counts
* Estimated edge counts
* Label / role cardinalities
* Histogram-like selectivity estimates

Statistics MAY be:

* Collected offline
* Approximated
* Missing (fallback applies)

---

### 6.2 Operator Intrinsics

Each logical operator has a **base cost model**:

| Operator  | Dominant Cost          |
| --------- | ---------------------- |
| Scan      | row_cost               |
| Filter    | compute_cost           |
| Project   | compute_cost           |
| Expand    | edge_cost              |
| Join      | row_cost × join_factor |
| Aggregate | memory_cost            |
| Limit     | negligible             |

---

### 6.3 Expression Cost

Expressions contribute to:

* `compute_cost`
* potential vector distance costs
* non-determinism penalties

From RFC-0003:

* Deterministic scalar functions: low
* Vector similarity: high
* Volatile functions: disallowed for costing

---

## 7. Expand & Adjacency Cost Model

Expand is the **distinguishing cost center**.

Cost factors:

* Fan-out (expected degree)
* Directionality
* Role constraints
* Predicate selectivity

Approximate model:

```
expand_cost ≈ input_rows × avg_degree × selectivity
```

Adjacency-backed expands receive a **cost discount**.

---

## 8. Join Cost Model

Join cost depends on:

* Join type (inner only in logical model)
* Key cardinality
* Input size symmetry

Rules:

* Star joins preferred over chains
* Join reorderings from RFC-0006 are evaluated here
* Outer joins are out of scope (future RFC)

---

## 9. Mode Eligibility Rules

A plan is **eligible** for an execution mode iff:

### 9.1 Relational Mode Eligibility

* No unresolved Expand operators
* All graph traversals compiled to joins
* No adjacency-only semantics required

---

### 9.2 Graph Mode Eligibility

* Expand operators present
* Adjacency semantics preserved
* No global aggregation blocking traversal

---

### 9.3 Hybrid Mode Eligibility

* Always eligible unless explicitly forbidden
* Required when vector + graph mixed predicates exist

---

## 10. Execution Mode Selection

### 10.1 Selection Algorithm (Normative)

1. Enumerate eligible modes
2. Estimate cost vector per mode
3. Apply mode-specific penalties
4. Select lowest weighted cost

---

### 10.2 Penalty Factors

| Situation                            | Penalty          |
| ------------------------------------ | ---------------- |
| Missing statistics                   | +uncertainty     |
| High fan-out Expand in relational    | +expand_penalty  |
| Large aggregation in graph mode      | +memory_penalty  |
| Vector similarity in graph-only plan | +compute_penalty |

Penalties MUST be explicit and explainable.

---

## 11. Fallback & Safety Rules

* If all costs exceed threshold → Hybrid mode
* If statistics are missing → Conservative estimates
* If modes tie → Prefer Hybrid → Relational → Graph

No query may fail solely due to cost estimation uncertainty.

---

## 12. Explainability & EXPLAIN Output

The system MUST support:

* Per-operator cost breakdown
* Mode eligibility explanation
* Penalty justification
* Final mode decision rationale

Example:

```
Chosen Mode: Hybrid
Reason:
  - Expand present (+graph)
  - Aggregation downstream (+relational)
  - Estimated fan-out low
```

---

## 13. Relationship to Rewrite Rules

* RFC-0006 rewrites generate candidates
* RFC-0007 scores candidates
* No rewrite rule may depend on cost feedback

This separation is **mandatory**.

---

## 14. Error Handling

Cost-related errors:

| Error             | Meaning                 |
| ----------------- | ----------------------- |
| NoEligibleMode    | Logical plan invalid    |
| CostOverflow      | Estimate exceeds bounds |
| InconsistentStats | Statistics conflict     |

Errors MUST degrade gracefully.

---

## 15. Open Questions

* Adaptive runtime feedback loops
* Learning-based cost models
* Multi-objective optimization (latency vs cost)
* Distributed execution costing

---

## 16. Conclusion

This RFC defines **how HyperFrame decides “how to run” a query**—without compromising correctness or transparency.

> **Rewrite rules preserve meaning.
> Cost models preserve sanity.**
