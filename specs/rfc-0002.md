# RFC-0002: HyperGraph Logical Algebra & Formal Semantics

**Status**: Draft
**Authors**: HyperGraph / Grism Team
**Last Updated**: 2026-01-21
**Depends on**: RFC-0001
**Supersedes**: —

---

## 1. Abstract

This RFC defines the **logical algebra and formal semantics** of HyperGraph.
It specifies the canonical set of logical operators, their inputs and outputs, their semantic meaning, and the invariants they must satisfy.

This document establishes HyperGraph’s **semantic contract**: all language frontends, optimizers, physical execution engines, and storage backends MUST preserve the semantics defined herein.

---

## 2. Scope and Non-Goals

### 2.1 Scope

This RFC defines:

* The **logical data model** exposed by HyperGraph
* The **logical operator set** and their semantics
* Column, role, and scope resolution rules
* Determinism, idempotence, and correctness guarantees
* Error classification at the logical layer

### 2.2 Non-Goals

This RFC explicitly does **not** define:

* Physical execution strategies
* Storage layout or indexing
* Cost models or optimization heuristics
* Query syntax (Cypher, AnkQL, Python API)
* Distributed execution semantics

These are covered by later RFCs.

---

## 3. Terminology

| Term             | Meaning                                                          |
| ---------------- | ---------------------------------------------------------------- |
| **HyperGraph**   | The canonical logical container representing a set of hyperedges |
| **Hyperedge**    | An n-ary relation instance                                       |
| **Role**         | A named position within a hyperedge                              |
| **Column**       | A typed attribute bound to a role or property                    |
| **Logical Plan** | A DAG of logical operators                                       |
| **Projection**   | A derived view preserving semantics                              |
| **Execution**    | A concrete realization of a logical plan                         |

Normative keywords (**MUST**, **SHOULD**, **MAY**) are used as defined in RFC 2119.

---

## 4. Logical Data Model

### 4.1 HyperGraph Definition

A **HyperGraph** is defined as:

> A finite multiset of hyperedges with schema, roles, and properties, together with a deterministic evaluation model.

Formally, a HyperGraph `H` consists of:

```
H = (E, S, P)
```

Where:

* `E`: a set of hyperedges
* `S`: a schema defining roles and column types
* `P`: a set of properties and metadata

---

### 4.2 Hyperedges

A hyperedge `e ∈ E` is defined as:

```
e = (id, type, roles, properties)
```

* `id`: globally unique identifier
* `type`: symbolic label
* `roles`: mapping from role name → entity identifier
* `properties`: mapping from property name → value

Hyperedges MAY share entities and roles.

---

### 4.3 Roles and Arity

* Hyperedges MAY have arbitrary arity ≥ 1
* Roles are **named**, not positional
* Role names are scoped to hyperedge type
* A role MUST bind exactly one entity per hyperedge instance

Binary edges are a special case where arity = 2.

---

### 4.4 Columns

A HyperGraph exposes a **columnar view**:

* Each role becomes a column
* Each property becomes a column
* Columns are typed
* Missing values are represented as `NULL`

Column names MUST be globally unique within a HyperGraph scope.

---

## 5. Logical Algebra Overview

HyperGraph defines a **closed logical algebra**.

> Every operator consumes one or more HyperGraphs and produces a HyperGraph.

No operator mutates input HyperGraphs.

---

### 5.1 Operator Categories

| Category    | Operators           |
| ----------- | ------------------- |
| Source      | `Scan`              |
| Navigation  | `Expand`            |
| Restriction | `Filter`            |
| Shape       | `Project`, `Rename` |
| Combination | `Join`, `Union`     |
| Aggregation | `Aggregate`         |
| Derivation  | `Infer`             |
| Control     | `Limit`, `Sort`     |

---

## 6. Operator Semantics (Normative)

### 6.1 Scan

**Signature**

```
Scan(source, predicate?) → HyperGraph
```

**Semantics**

* Produces a HyperGraph containing all hyperedges from `source`
* Optional predicate restricts by type or metadata
* Order is undefined

**Invariants**

* Deterministic
* Side-effect free

---

### 6.2 Expand

**Signature**

```
Expand(input, pattern, direction?) → HyperGraph
```

**Semantics**

* Navigates from bound roles to adjacent hyperedges
* Introduces new roles into scope
* Does not alter existing bindings

**Rules**

* Expansion preserves hyperedge identity
* Role collisions MUST be resolved explicitly
* Direction is semantic, not physical

Expand MUST NOT imply adjacency traversal; adjacency is an execution concern.

---

### 6.3 Filter

**Signature**

```
Filter(input, predicate) → HyperGraph
```

**Semantics**

* Retains hyperedges where predicate evaluates to true
* Predicate is a boolean expression over columns

**Rules**

* Three-valued logic (`TRUE`, `FALSE`, `UNKNOWN`)
* Only `TRUE` rows survive
* `UNKNOWN` behaves as `FALSE`

---

### 6.4 Project

**Signature**

```
Project(input, columns) → HyperGraph
```

**Semantics**

* Reduces column set
* Does not alter hyperedge identity

**Rules**

* Dropping a role removes it from scope
* Project MUST NOT change cardinality

---

### 6.5 Rename

**Signature**

```
Rename(input, mapping) → HyperGraph
```

**Semantics**

* Renames columns or roles
* Purely symbolic

---

### 6.6 Join

**Signature**

```
Join(left, right, condition) → HyperGraph
```

**Semantics**

* Relational join over column equality
* Produces composed hyperedges

**Rules**

* Join introduces new hyperedges
* Join MAY increase arity
* Join MUST preserve correctness even if expensive

Join is always semantically valid but not always desirable.

---

### 6.7 Union

**Signature**

```
Union(left, right) → HyperGraph
```

**Semantics**

* Multiset union
* Schemas MUST be compatible

---

### 6.8 Aggregate

**Signature**

```
Aggregate(input, keys, functions) → HyperGraph
```

**Semantics**

* Groups hyperedges by keys
* Computes aggregate functions

**Rules**

* Produces new hyperedges
* Aggregate functions MUST be associative and deterministic

---

### 6.9 Infer

**Signature**

```
Infer(input, ruleset) → HyperGraph
```

**Semantics**

* Applies declarative rules
* May introduce new hyperedges

**Rules**

* Infer MUST be monotonic unless explicitly stated
* Fixpoint semantics MAY apply (defined in RFC-0013)

---

### 6.10 Limit / Sort

Purely logical constraints; execution order is unspecified unless enforced.

---

## 7. Scope and Name Resolution

### 7.1 Scoping Rules

* Each operator defines a new scope
* Column references resolve lexically
* Ambiguity MUST be rejected

### 7.2 Role Shadowing

Role names MAY be shadowed only via explicit rename.

Implicit shadowing is forbidden.

---

## 8. Determinism & Correctness Guarantees

HyperGraph guarantees:

* **Referential transparency**
* **Deterministic results**
* **Snapshot isolation**
* **Idempotent evaluation**

Given identical inputs and snapshot, results MUST be identical.

---

## 9. Error Model

Errors are classified as:

| Class        | Description                               |
| ------------ | ----------------------------------------- |
| Construction | Invalid plan or schema                    |
| Validation   | Type or scope mismatch                    |
| Semantic     | Invalid operation (e.g., ambiguous roles) |
| Execution    | Resource or backend failure               |

Logical planning MUST surface errors before execution whenever possible.

---

## 10. Rewrite Safety Rules

A rewrite is **legal** iff:

* It preserves hyperedge identity semantics
* It does not alter NULL behavior
* It does not introduce or remove hyperedges

This RFC defines *what must be preserved*, not *how* to optimize.

---

## 11. Relationship to RFC-0001

RFC-0001 defines:

* HyperGraph as the **source of truth**
* Adjacency as a **projection**

RFC-0002 defines:

* The **meaning** of HyperGraph operations

No RFC may override RFC-0002 semantics without an explicit amendment.

---

## 12. Open Questions

* Formalization of path semantics over hyperedges
* Cost-aware semantic annotations
* Partial evaluation semantics

---

## 13. Conclusion

This RFC establishes HyperGraph’s **semantic bedrock**.
Everything else—Cypher compatibility, adjacency traversal, graph algorithms, distributed execution—is a *projection of this algebra*.

> **HyperGraph is not a graph that happens to support joins.
> It is a semantic system that happens to support traversal.**
