# RFC-0002: Hypergraph Logical Algebra & Formal Semantics

**Status**: Frozen
**Authors**: Grism Team
**Created**: 2026-01-21
**Last Updated**: 2026-01-21
**Depends on**: RFC-0001
**Supersedes**: —

---

## 1. Abstract

This RFC defines the **logical algebra and formal semantics** of Hypergraph.
It specifies the canonical set of logical operators, their inputs and outputs, their semantic meaning, and the invariants they must satisfy.

This document establishes Hypergraph's **semantic contract**: all language frontends, optimizers, physical execution engines, and storage backends MUST preserve the semantics defined herein.

---

## 2. Scope and Non-Goals

### 2.1 Scope

This RFC defines:

* The **logical data model** exposed by Hypergraph
* The **logical operator set** and their semantics
* Column, role, and scope resolution rules
* Determinism, idempotence, and correctness guarantees
* Error classification at the logical layer

### 2.2 Non-Goals

This RFC explicitly does **not** define:

* Physical execution strategies
* Storage layout or indexing
* Cost models or optimization heuristics
* Query syntax (Cypher, AnkQL, Python API)
* Distributed execution semantics

These are covered by later RFCs.

---

## 3. Terminology

| Term             | Meaning                                                          |
| ---------------- | ---------------------------------------------------------------- |
| **Hypergraph**   | The canonical logical container representing a set of hyperedges |
| **Hyperedge**    | An n-ary relation instance (arity ≥ 2)                           |
| **Role**         | A named position within a hyperedge                              |
| **Property**     | A typed attribute bound to a role or entity                      |
| **Logical Plan** | A DAG of logical operators                                       |
| **Projection**   | A derived view preserving semantics                              |
| **Execution**    | A concrete realization of a logical plan                         |

Normative keywords (**MUST**, **SHOULD**, **MAY**) are used as defined in RFC 2119.

---

## 4. Logical Data Model

### 4.1 Hypergraph Definition

A **Hypergraph** is defined as:

> A finite multiset of hyperedges with schema, roles, and properties, together with a deterministic evaluation model.

Formally, a Hypergraph `H` consists of:

```
H = (E, S, P)
```

Where:

* `E`: a set of hyperedges
* `S`: a schema defining roles and column types
* `P`: a set of properties and metadata

---

### 4.2 Hyperedges

A hyperedge `e ∈ E` is defined as:

```
e = (id, type, roles, properties)
```

* `id`: globally unique identifier
* `type`: symbolic label
* `roles`: mapping from role name → entity identifier
* `properties`: mapping from property name → value

Hyperedges MAY share entities and roles.

---

### 4.3 Roles and Arity

* Hyperedges MUST have arity ≥ 2
* Roles are **named**, **unordered**, and **semantically meaningful**
* Role names are scoped to hyperedge type
* A role MUST bind exactly one entity per hyperedge instance

Binary edges are a special case where arity = 2 with conventional roles `{source, target}`.

---

### 4.4 Properties and Columns

A Hypergraph exposes a **columnar view** through Frames:

* Each role becomes a column reference
* Each property becomes a column reference
* Columns are typed according to the Value system
* Missing values are represented as `NULL`

Column references resolve within Frame scopes as defined in the architecture (Section 6.2).

---

## 5. Logical Algebra Overview

Hypergraph defines a **closed logical algebra**.

> Every operator consumes one or more Hypergraphs and produces a Hypergraph.

No operator mutates input Hypergraphs.

---

### 5.1 Operator Categories

| Category    | Operators                    |
| ----------- | ---------------------------- |
| Source      | `Scan`                       |
| Navigation  | `Expand`                     |
| Restriction | `Filter`                     |
| Shape       | `Project`, `Rename`          |
| Combination | `Union`                      |
| Aggregation | `Aggregate`                  |
| Derivation  | `Infer`                      |
| Control     | `Limit`, `Sort`              |

**Important**: There is **no Join operator**. Relational composition is expressed via `Expand`.

---

## 6. Operator Semantics (Normative)

### 6.1 Scan

**Signature**

```
Scan(source, predicate?) → Hypergraph
```

**Semantics**

* Produces a Hypergraph containing all hyperedges from `source`
* Optional predicate restricts by type or metadata
* Order is undefined

**Invariants**

* Deterministic
* Side-effect free

---

### 6.2 Expand

**Signature**

```
Expand(input, pattern, direction?, materialize?) → Hypergraph
```

**Semantics**

* Follows role bindings in hyperedges
* Introduces new roles into scope
* Does not alter existing bindings

**Modes**

* **BinaryExpand**: For arity = 2 hyperedges with `{source, target}` roles
* **RoleExpand**: For role-qualified traversal over n-ary hyperedges
* **MaterializeHyperedge**: When hyperedges should appear as first-class outputs

**Rules**

* Expansion preserves hyperedge identity
* Role collisions MUST be resolved explicitly
* Direction is semantic, not physical
* Expand is the **sole traversal primitive** - no separate Join operator

Expand MUST NOT imply adjacency traversal; adjacency is an execution concern.

---

### 6.3 Filter

**Signature**

```
Filter(input, predicate) → Hypergraph
```

**Semantics**

* Retains hyperedges where predicate evaluates to true
* Predicate is a boolean expression over columns

**Rules**

* Three-valued logic (`TRUE`, `FALSE`, `UNKNOWN`)
* Only `TRUE` rows survive
* `UNKNOWN` behaves as `FALSE`

---

### 6.4 Project

**Signature**

```
Project(input, columns) → Hypergraph
```

**Semantics**

* Reduces column set
* Does not alter hyperedge identity

**Rules**

* Dropping a role removes it from scope
* Project MUST NOT change cardinality

---

### 6.5 Rename

**Signature**

```
Rename(input, mapping) → Hypergraph
```

**Semantics**

* Renames columns or roles
* Purely symbolic

---

### 6.6 Union

**Signature**

```
Union(left, right) → Hypergraph
```

**Semantics**

* Multiset union
* Schemas MUST be compatible

---

### 6.7 Aggregate

**Signature**

```
Aggregate(input, keys, functions) → Hypergraph
```

**Semantics**

* Groups hyperedges by keys
* Computes aggregate functions

**Rules**

* Produces new hyperedges
* Aggregate functions MUST be associative and deterministic

---

### 6.8 Infer

**Signature**

```
Infer(input, ruleset) → Hypergraph
```

**Semantics**

* Applies declarative rules
* May introduce new hyperedges

**Rules**

* Infer MUST be monotonic unless explicitly stated
* Fixpoint semantics MAY apply (defined in RFC-0013)

---

### 6.9 Limit / Sort

Purely logical constraints; execution order is unspecified unless enforced.

---

## 7. Scope and Name Resolution

### 7.1 Frame-Based Scoping Rules

* Each Frame defines a new scope
* Column references resolve against the **frame scope stack**
* Ambiguity MUST be rejected with error messages

### 7.2 Resolution Hierarchy

1. **Qualified references** (`col("Author.name")`) - resolved against explicit labels
2. **Unqualified references** (`col("name")`) - resolved by most-recent scope first
3. **Post-expand scope** - original frame columns remain visible
4. **Post-select scope** - only projected columns remain visible

### 7.3 Role Shadowing

Role names MAY be shadowed only via explicit rename.

Implicit shadowing is forbidden.

---

## 8. Determinism & Correctness Guarantees

Hypergraph guarantees:

* **Referential transparency**
* **Deterministic results**
* **Snapshot isolation**
* **Idempotent evaluation**

Given identical inputs and snapshot, results MUST be identical.

---

## 9. Error Model

Errors are classified as:

| Class        | Description                               |
| ------------ | ----------------------------------------- |
| Construction | Invalid plan or schema                    |
| Validation   | Type or scope mismatch                    |
| Semantic     | Invalid operation (e.g., ambiguous roles) |
| Execution    | Resource or backend failure               |

Logical planning MUST surface errors before execution whenever possible.

---

## 10. Rewrite Safety Rules

A rewrite is **legal** iff:

* It preserves hyperedge identity semantics
* It does not alter NULL behavior
* It does not introduce or remove hyperedges

This RFC defines *what must be preserved*, not *how* to optimize.

---

## 11. Relationship to RFC-0001

RFC-0001 defines:

* Hypergraph as the **source of truth**
* Adjacency as a **projection**

RFC-0002 defines:

* The **meaning** of Hypergraph operations

No RFC may override RFC-0002 semantics without an explicit amendment.

---

## 12. Open Questions

* Formalization of path semantics over hyperedges
* Cost-aware semantic annotations
* Partial evaluation semantics

---

## 13. Conclusion

This RFC establishes Hypergraph’s **semantic bedrock**.
Everything else—Cypher compatibility, adjacency traversal, graph algorithms, distributed execution—is a *projection of this algebra*.

> **Hypergraph is not a graph that happens to support relational operations.
> It is a semantic system that happens to support traversal through Expand.**
