# RFC-0016: Constraints & Integrity

**Status**: Draft
**Authors**: Grism Team
**Created**: 2026-01-21
**Last Updated**: 2026-01-21
**Depends on**: RFC-0002, RFC-0003, RFC-0015, RFC-0012
**Supersedes**: —

---

## 1. Abstract

This RFC defines the **constraints and integrity model** for Hypergraph.

Hypergraph operates in a space where:

* Data is accumulated over long time horizons
* Knowledge is partially inferred, not fully asserted
* Symbolic reasoning coexists with neural approximation
* Agents may write data autonomously

In such systems, **integrity cannot be an afterthought**.

However, traditional database constraints assume:

* Fully known schemas
* Closed-world semantics
* Immediate enforcement

These assumptions do not hold for Hypergraph.

This RFC defines a **graded, schema-aware, hypergraph-native constraint system** that:

* Preserves correctness without blocking evolution
* Supports reasoning over incomplete knowledge
* Allows delayed and observational enforcement
* Treats constraints as *semantic contracts*, not rigid rules

---

## 2. Scope and Non-Goals

### 2.1 Scope

This RFC specifies:

* Constraint definition and taxonomy
* Schema-version-aware enforcement modes
* Violation handling as knowledge, not errors
* Integration with planning and reasoning layers

### 2.2 Non-Goals

This RFC does **not** define:

* Full relational-style ACID enforcement
* Global synchronous constraint checking
* Hard real-time guarantees

---

## 3. Design Principles

1. **First-class constraint definitions**
2. **Schema-version-aware enforcement**
3. **Multiple enforcement modes**
4. **Hypergraph-native constraints**
5. **Compatibility with append-only storage**
6. **Constraint visibility to planner and reasoning layers**

---

## 3. Constraint Model Overview

Constraints are **declarative objects** associated with schemas.

Each constraint has:

* Identity and version
* Scope (node, edge, hyperedge, property)
* Predicate definition
* Enforcement mode
* Violation semantics

Constraints are immutable once published.

---

## 4. Constraint Taxonomy

### 4.1 Property Constraints

Applied to individual properties.

Examples:

* NOT NULL
* Type conformity
* Range constraints
* Regex / pattern constraints

```text
PropertyConstraint {
  target: PropertyRef
  predicate: Expression
  severity: Severity
}
```

---

### 4.2 Entity Constraints

Applied to nodes or hyperedges.

Examples:

* Required properties
* Mutual exclusivity
* Conditional presence

Example:

> A `Person` must have at least one of `{email, phone}`.

---

### 4.3 Uniqueness Constraints

Ensure uniqueness within a defined scope.

Scopes may be:

* Global
* Per label
* Per role (hyperedge)
* Per partition

Example:

> `Person.email` is unique among all `Person` nodes.

Uniqueness constraints are **best-effort** under append-only storage.

---

### 4.4 Referential Integrity Constraints

Ensure references are valid.

Examples:

* Hyperedge role bindings must exist
* Optional vs required references

Referential constraints may be:

* Strong (must exist at write time)
* Weak (may be resolved later)

---

### 4.5 Cardinality Constraints (Hypergraph-Native)

Define role multiplicity for hyperedges.

```text
Role: Author
Cardinality: [1..*]
```

These constraints are essential for:

* Reasoning correctness
* Query planning
* Structural validation

---

### 4.6 Temporal Constraints

Constraints over time.

Examples:

* Validity intervals
* Event ordering
* Monotonic properties

Temporal constraints integrate with:

* Snapshot semantics
* Provenance tracking

---

## 5. Constraint Definition Language

Constraints are defined using **typed expressions** from RFC-0003.

Example:

```cypher
CONSTRAINT Person.email_unique
ON (p:Person)
ASSERT UNIQUE(p.email)
ENFORCEMENT DEFERRED
```

Constraints may reference:

* Properties
* Roles
* Derived expressions

---

## 6. Enforcement Modes

Grism supports **graded enforcement**, configurable per constraint.

| Mode          | Behavior                              |
| ------------- | ------------------------------------- |
| Strict        | Reject violating writes               |
| Deferred      | Allow writes, validate asynchronously |
| Observational | Record violations only                |
| Advisory      | Exposed to planner, not enforced      |

Enforcement mode is part of constraint identity.

---

## 7. Enforcement Semantics

### 7.1 Write-Time Enforcement

* Applied during ingestion or mutation
* May be partial (best-effort)
* Never rewrites existing data

---

### 7.2 Query-Time Enforcement

* Violations may surface as:

  * NULLs
  * Filtered rows
  * Warnings
* Planner may rewrite queries to avoid invalid data

---

### 7.3 Background Validation

Deferred constraints are validated via:

* Batch jobs
* Incremental scans
* Agent-triggered audits

Violations are stored as first-class facts.

---

## 8. Violations as Data

Constraint violations are **not exceptions** — they are **knowledge**.

Each violation is stored as:

```text
ConstraintViolation {
  constraint_id
  entity_id
  schema_version
  timestamp
  severity
  context
}
```

This enables:

* Auditing
* Learning-based cleanup
* Agent-driven repair

---

## 9. Planner & Optimizer Interaction

Constraints inform planning:

* Uniqueness → join elimination
* Cardinality → cost estimation
* Non-null → predicate pushdown
* Advisory constraints → heuristic optimization

Constraints never invalidate plans at runtime.

---

## 10. Storage & Performance Considerations

* Constraint metadata stored separately from data
* No mandatory indexes required
* Optional acceleration structures may be created
* Lance append-only model is respected

---

## 11. Schema Evolution & Constraints

Constraints are schema-versioned.

Rules:

* Compatible schema evolution preserves constraints
* Breaking schema changes require explicit constraint migration
* Constraints may be retired but never silently changed

---

## 12. Interaction with Reasoning Layer

Constraints may be:

* Used as axioms
* Treated as soft rules
* Violated by inferred facts with explicit marking

Reasoning engines may generate:

* New constraints
* Suggested repairs
* Confidence scores

---

## 13. Failure & Degradation Model

* Constraint failures never crash the system
* Violations degrade result quality, not availability
* Strict mode is opt-in

---

## 14. Open Questions

1. Should constraint violations influence cost model?
2. How to express probabilistic constraints?
3. Should constraints themselves be learnable?

---

## 15. Summary

This RFC establishes constraints in Hypergraph as:

* **Declarative and versioned**
* **Hypergraph-aware**
* **Gradually enforced**
* **Visible to planners and reasoners**
* **Represented as knowledge, not errors**

> **In Hypergraph, integrity is not about forbidding inconsistency —
> it is about making inconsistency explicit, traceable, and correctable.**
