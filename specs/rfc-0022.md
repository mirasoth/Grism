# RFC-0022: Write & Mutation Semantics

**Status**: Draft
**Authors**: Grism Team
**Created**: 2026-01-23
**Last Updated**: 2026-01-23
**Depends on**: RFC-0012, RFC-0018, RFC-0019, RFC-0020, RFC-0021, RFC-0102
**Supersedes**: —

---

## 1. Abstract

This RFC defines the **write and mutation semantics** for Grism storage.

It specifies a **backend-agnostic, snapshot-oriented mutation model** that applies uniformly to all storage backends, including in-memory, local Lance, and cloud Lance implementations.

The goal is to provide:

* Deterministic snapshot evolution
* Clear separation between reads and writes
* Explicit materialization of adjacency and fragments

---

## 2. Scope and Non-Goals

### 2.1 Scope

This RFC specifies:

* The write model and lifecycle
* Snapshot creation and publication
* Mutation visibility rules
* Adjacency materialization timing

### 2.2 Non-Goals

This RFC does **not** define:

* Fine-grained transactional isolation levels
* Concurrent multi-writer coordination
* Locking or conflict resolution
* User-facing DML syntax

---

## 3. Design Principles

### 3.1 Snapshot-Oriented Mutation

All mutations in Grism occur **against a mutable working snapshot**, producing a new immutable snapshot upon publication.

No mutation is ever applied in-place to a published snapshot.

---

### 3.2 Single-Writer Snapshot Assumption

At the level of this RFC, snapshot mutation assumes a **single logical writer**.

Multi-writer coordination is explicitly out of scope and delegated to higher-level systems.

---

### 3.3 Explicit Materialization

All derived structures (adjacency, fragments, indices) are explicitly materialized during snapshot publication.

There is no implicit or lazy mutation of published data.

---

## 4. Write Lifecycle

The write lifecycle proceeds in four explicit phases:

```
Begin → Mutate → Materialize → Publish
```

---

### 4.1 Begin

A mutable snapshot context is created:

```
WorkingSnapshot {
  base_snapshot: SnapshotId,
  buffers: WriteBuffers
}
```

The base snapshot MUST be immutable.

---

### 4.2 Mutate

Mutations include:

* Node insertion
* Hyperedge insertion
* Property updates
* Deletions (logical)

Mutations are accumulated in write buffers and are not visible to readers.

---

### 4.3 Materialize

During materialization:

* Write buffers are converted into columnar datasets
* Adjacency datasets are rebuilt or incrementally derived
* Fragment boundaries are established
* Fragment and adjacency metadata are finalized

Materialization MUST be deterministic.

---

### 4.4 Publish

Publication:

* Assigns a new `SnapshotId`
* Makes the snapshot visible to readers
* Freezes all underlying data

After publication, the snapshot is read-only.

---

## 5. Mutation Semantics

### 5.1 Insertions

Insertions append new rows to node or hyperedge datasets.

IDs are assigned during materialization and are snapshot-local.

---

### 5.2 Updates

Updates are implemented as **copy-on-write** at snapshot granularity.

In-place updates to published data are forbidden.

---

### 5.3 Deletions

Deletions are logical:

* Rows are marked as deleted via metadata or tombstones
* Physical removal MAY occur during compaction (out of scope)

Deleted entities are invisible in the published snapshot.

---

## 6. Adjacency Materialization

Adjacency datasets are materialized during the **Materialize** phase.

Rules:

* All adjacency specifications declared in the schema MUST be satisfied
* Materialization order MUST be deterministic
* AdjacencyFragmentMeta MUST fully describe the resulting layout

No adjacency is built lazily at read time.

---

## 7. Fragment Semantics

Fragments are established during materialization.

Rules:

* Fragment boundaries are snapshot-stable
* Fragment metadata is immutable post-publication
* Fragment layout MAY differ between snapshots

---

## 8. Backend-Specific Considerations

### 8.1 In-Memory Backend

* Write buffers MAY directly become published batches
* No persistence guarantees apply

---

### 8.2 Local Lance Backend

* Materialization writes new Lance datasets
* Publication is atomic at snapshot directory granularity

---

### 8.3 Cloud / ObjectStore Lance Backend

* Materialization writes to a staging prefix
* Publication requires external coordination
* No rename or atomic directory assumptions are permitted

---

## 9. Visibility and Isolation

Readers observe:

* Only fully published snapshots
* Never partially materialized data

There is no concept of dirty reads.

---

## 10. Failure Semantics

If a failure occurs:

* During mutation or materialization → snapshot is discarded
* During publication → snapshot visibility is undefined and must be resolved externally

Published snapshots are never corrupted.

---

## 11. Guarantees

This RFC guarantees:

1. Deterministic snapshot evolution
2. Clear separation between reads and writes
3. Backend-independent mutation semantics
4. Explicit adjacency and fragment materialization

---

## 12. Relationship to Other RFCs

* **RFC-0012**: Storage abstractions
* **RFC-0018**: Persistent storage & adjacency layout
* **RFC-0019**: Local Lance backend
* **RFC-0020**: In-memory backend
* **RFC-0021**: Cloud Lance backend
* **RFC-0102**: Execution engine architecture

RFC-0022 defines the **shared mutation contract** for all storage backends.

---

## 13. Summary

The write and mutation semantics defined here:

* Establish snapshots as the unit of change
* Prevent in-place mutation of published data
* Make adjacency and fragment layout explicit and deterministic

They complete the core storage contract of Grism.
