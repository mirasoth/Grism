# RFC-0003: Expression System & Type Model

**Status**: Frozen
**Authors**: Grism Team
**Created**: 2026-01-21
**Last Updated**: 2026-01-21
**Depends on**: RFC-0002
**Supersedes**: —

---

## 1. Abstract

This RFC defines the **expression system and type model** for Hypergraph.
Expressions are the smallest executable semantic units used in predicates, projections, relational composition, aggregations, and inference rules.

This document establishes:

* A canonical **Expression IR**
* A deterministic **type system**
* Rules for **type checking, coercion, and nullability**
* Guarantees required for optimization and execution

All frontends (Cypher, AnkQL, Python) and all execution engines MUST conform to this specification.

---

## 2. Scope and Non-Goals

### 2.1 Scope

This RFC specifies:

* Expression abstract syntax tree (AST)
* Literal, column, and function expressions
* Type system and null semantics
* Function classification and determinism
* Binding and evaluation rules
* Serialization requirements

### 2.2 Non-Goals

This RFC does **not** define:

* Query syntax
* Cost or selectivity estimation
* Physical evaluation strategies
* Vector index semantics
* Ontology or reasoning rules (see RFC-0013)

---

## 3. Design Principles

1. **Determinism first**
   Expressions must be referentially transparent unless explicitly marked otherwise.

2. **Language neutrality**
   Expressions form a shared IR across Python and Rust.

3. **Static validation**
   All type errors SHOULD be detected prior to execution.

4. **Columnar semantics**
   Expressions operate over columns, not rows.

---

## 4. Expression Model Overview

An **Expression** represents a pure computation over zero or more input columns.

Formally:

```
Expr := f(inputs, metadata)
```

Where:

* `inputs` are zero or more sub-expressions
* `metadata` includes type, nullability, and function attributes

Expressions form a **directed acyclic graph (DAG)**.

---

## 5. Expression Categories

### 5.1 Literal Expressions

Represent constant values.

Examples:

* `Int(42)`
* `String("alice")`
* `Null(Int)`

Rules:

* Literals have a fully resolved static type
* `NULL` literals MUST carry an explicit type

---

### 5.2 Column Reference Expressions

Refer to columns in the current Frame scope.

```
ColumnRef(name)
```

Rules:

* Name resolution follows the frame scope stack (RFC-0002, Section 7)
* Column MUST exist at plan validation time
* ColumnRef does not perform dereferencing or traversal
* Supports qualified references (`col("Author.name")`) and unqualified references

---

### 5.3 Unary Expressions

Examples:

* `Not(expr)`
* `Neg(expr)`
* `IsNull(expr)`

Rules:

* Input type must be compatible
* Output type is statically known

---

### 5.4 Binary Expressions

Examples:

* Arithmetic: `Add`, `Sub`, `Mul`
* Comparison: `Eq`, `Lt`, `Gt`
* Logical: `And`, `Or`

Rules:

* Operands are type-checked
* Implicit casts MAY apply (see §8)
* Comparisons over NULL yield `UNKNOWN`

---

### 5.5 Function Call Expressions

```
Call(function_name, args)
```

Functions are registered in a **global function registry**.

Rules:

* Arity must match
* Argument types must be compatible
* Function metadata determines determinism and null behavior

---

### 5.6 Conditional Expressions

```
If(condition, then_expr, else_expr)
```

Rules:

* Condition must be boolean
* Result type is the least common supertype
* Three-valued logic applies

---

### 5.7 Aggregate Expressions

Used only within `Aggregate` operators.

Examples:

* `Count(*)`
* `Sum(expr)`
* `Collect(expr)`

Rules:

* Aggregates cannot be nested
* Aggregates cannot appear outside Aggregate context
* Deterministic unless explicitly stated

---

### 5.8 Collection & Struct Expressions

Supported compound types:

* `Array<T>`
* `Struct{field: T}`

Rules:

* Field access is static
* Collections preserve element type

---

## 6. Type System

### 6.1 Value Types (Canonical)

The type system aligns with the Value enumeration defined in the architecture (Section 3.2):

| Type        | Description                    |
| ----------- | ------------------------------ |
| `Bool`      | Three-valued boolean           |
| `Int`       | Signed 64-bit integer          |
| `Float`     | IEEE double                    |
| `String`    | UTF-8                          |
| `Binary`    | Binary data                    |
| `Timestamp` | Nanoseconds since epoch        |
| `Date`      | Days since epoch               |
| `Null`      | Explicit null value            |

---

### 6.2 Graph-Native Types

| Type          | Description          |
| ------------- | -------------------- |
| `NodeId`      | Node identifier      |
| `EdgeId`      | Hyperedge identifier |
| `Label`       | Symbolic label       |
| `Role`        | Role name            |
| `SymbolId`    | Symbol identifier    |

These are logical types; physical representation is unspecified.

---

### 6.3 AI-Native Types

| Type           | Description                 |
| -------------- | --------------------------- |
| `Vector`       | Fixed-dimension embedding   |
| `Tensor`       | Higher-order numeric tensor |
| `Score`        | Comparable scalar score     |

Distance and similarity functions (e.g., `sim()`) are defined as pure functions.

---

### 6.4 Nullability

Every type is implicitly nullable.

```
T := Nullable<T>
```

Rules:

* NULL propagates unless overridden
* `IsNull` is the only NULL-safe predicate
* No implicit NULL-to-value coercion

---

## 7. Three-Valued Logic

Boolean expressions operate in Kleene logic:

| A | B | A AND B | A OR B |
| - | - | ------- | ------ |
| T | T | T       | T      |
| T | F | F       | T      |
| T | U | U       | T      |
| F | * | F       | *      |
| U | U | U       | U      |

Filter semantics are defined in RFC-0002.

---

## 8. Type Checking & Coercion

### 8.1 Static Type Checking

Validation MUST ensure:

* All expressions are well-typed
* All functions exist
* No illegal aggregates

Ill-typed plans MUST be rejected.

---

### 8.2 Implicit Coercion Rules

Permitted coercions include:

* `Int → Float` (safe widening)
* `Float → String` (explicit only via `cast()`)
* `NodeId → String` (explicit only via `cast()`)
* `EdgeId → String` (explicit only via `cast()`)
* Numeric widening

Implicit narrowing is forbidden. All type conversions must use explicit `cast()` function unless listed as permitted implicit coercions.

---

### 8.3 Type Unification

In expressions like `If`, `Case`, or `Union`:

* Result type is the least common supertype
* Failure to unify is a validation error

---

## 9. Function Registry

Each function is defined by metadata:

```
Function {
  name
  arity
  input_types
  output_type
  deterministic
  null_behavior
  category
}
```

### 9.1 Function Categories

| Category     | Description                            |
| ------------ | -------------------------------------- |
| Scalar       | Row-wise pure function                 |
| Aggregate    | Group-wise function                    |
| Predicate    | Boolean-valued                         |
| Vector       | Vector similarity and distance         |
| Type         | Casting and type conversion            |
| Utility      | Formatting and other utilities         |

---

### 9.2 Determinism Flags

Functions MUST declare:

* Deterministic
* Stable (snapshot-dependent)
* Volatile (non-deterministic)

Only deterministic functions may be used in:

* Index predicates
* Materialized views
* Rewrite rules

---

## 10. Binding & Evaluation Semantics

* Expressions are evaluated against Frame rows (RecordBatch in execution)
* No side effects permitted
* Evaluation order is undefined unless specified
* Short-circuiting is logical, not physical
* Column references resolve according to Frame scope rules

---

## 11. Serialization & Interchange

Expressions MUST support:

* Lossless serialization
* Stable hashing
* Cross-language round-tripping

Recommended formats:

* Rust enum
* JSON (canonical)
* Protobuf (optional)

---

## 12. Rewrite Safety Rules

An expression rewrite is legal iff:

* It preserves output value for all inputs
* It preserves NULL semantics
* It does not change determinism classification

Examples of legal rewrites:

* Constant folding
* Predicate normalization

---

## 13. Error Model

Expression-related errors:

| Class       | Description                |
| ----------- | -------------------------- |
| Resolution  | Unknown column or function |
| Type        | Type mismatch              |
| Nullability | Invalid NULL usage         |
| Context     | Aggregate misuse           |

Errors SHOULD surface during logical planning.

---

## 14. Relationship to Other RFCs

* **RFC-0001**: Defines Hypergraph as the container
* **RFC-0002**: Defines logical operators using expressions
* **RFC-0006**: Uses expressions for rewrite rules
* **RFC-0009**: Uses expression determinism for index eligibility
* **RFC-0013**: Extends expressions for reasoning

No RFC may redefine expression semantics without amending RFC-0003.

---

## 15. Open Questions

* Higher-order functions over collections
* Window functions (future RFC)
* Probabilistic expressions
* Lazy vs eager evaluation annotations

---

## 16. Conclusion

This RFC defines the **semantic atoms** of Hypergraph.
Expressions are where *logic becomes executable*.

> **If RFC-0002 defines "what a query means",
> RFC-0003 defines "how meaning is computed—safely, deterministically, and portably across Frames".**
