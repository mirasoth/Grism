# RFC-0009: Indexing, Adjacency & Access Paths

**Status**: Review
**Authors**: Grism Team
**Created**: 2026-01-21
**Last Updated**: 2026-01-23
**Depends on**: RFC-0002, RFC-0006, RFC-0007, RFC-0008, RFC-0012, RFC-0102
**Supersedes**: â€”

---

## 1. Abstract

This RFC defines the **indexing, adjacency, and access path model** for Grism.

Indexes and adjacency structures are **semantic accelerators**: they never change logical meaning, but constrain *how* data is reached from storage during execution. This RFC specifies:

* Logical index abstractions and guarantees
* Adjacency as a first-class access path for hypergraph traversal
* Planner visibility and eligibility rules
* Binding constraints between planning, execution, and storage

This RFC forms the **contractual bridge** between the storage layer (RFC-0012) and the execution architecture (RFC-0102).

---

## 2. Scope and Non-Goals

### 2.1 Scope

This RFC specifies:

* Logical index and adjacency abstractions
* Access path contracts and guarantees
* Planner discovery and eligibility rules
* Execution-time binding semantics

### 2.2 Non-Goals

This RFC does **not** define:

* Physical index implementations
* On-disk or in-memory data structures
* Index maintenance or mutation protocols
* Transactional correctness
* Statistics collection (see RFC-0007)

---

## 3. Core Design Principles

### 3.1 Semantics Preservation

Indexes and adjacency access paths MUST NOT change logical results.

They may:

* Restrict execution strategies
* Reduce scanned data
* Alter performance characteristics

They MUST NOT:

* Filter implicitly
* Introduce ordering unless guaranteed
* Alter hypergraph semantics

---

### 3.2 Explicit Guarantees Only

Every index or adjacency structure MUST explicitly declare its guarantees.

Execution and planning MUST assume **nothing beyond declared guarantees**.

---

### 3.3 Adjacency Is a Primitive, Not a Join

Adjacency represents **topological reachability** in the hypergraph.

It is:

* Role-aware
* Directional
* Arity-preserving

Adjacency MUST NOT be modeled as relational composition or join rewriting.

---

### 3.4 Planner-Visible, Execution-Bound

Indexes and adjacency are:

* Fully visible to the planner
* Bound during physical planning
* Accessed during execution via `ExecutionContextTrait`

---

## 4. Access Path Model

### 4.1 Access Path Definition

An **Access Path** is a logical method of retrieving records that satisfy a constraint.

Examples:

* Full dataset scan
* Predicate-backed index scan
* Adjacency traversal
* Vector similarity search

Access paths are **not operators**. They are *execution strategies* selected during physical planning.

Access paths exclude **distribution and synchronization operators** (e.g., `ExchangeExec`), which are modeled explicitly as physical operators in RFC-0102.

---

### 4.2 Access Path Guarantees

Each access path MUST declare:

* Covered entities or columns
* Determinism
* Completeness (exact vs approximate)
* Ordering guarantees (if any)
* Cardinality constraints (if bounded)

---

## 5. Logical Index Model

### 5.1 Index Definition

A logical index is defined as:

```
Index {
  name
  indexed_entity
  indexed_columns
  index_type
  guarantees
}
```

Indexes are **read-only** from the planner and execution perspective.

---

### 5.2 Index Categories

#### 5.2.1 Value Index

Supports equality and range predicates.

Guarantees:

* Exact match semantics
* No false positives

---

#### 5.2.2 Composite Index

Indexes multiple columns with ordered significance.

Guarantees:

* Prefix matching
* Column order sensitivity

---

#### 5.2.3 Full-Text Index

Supports textual predicates.

Guarantees:

* Exact or approximate (explicitly declared)
* Optional scoring

---

#### 5.2.4 Vector Index

Supports similarity search over embedding spaces.

Guarantees:

* Metric consistency
* Exact or approximate (explicitly declared)
* Top-K semantics

Approximate vector indexes MUST declare recall guarantees.

---

## 6. Adjacency Model

This section defines adjacency as an access path abstraction. For persistent adjacency storage layout, see **RFC-0018**.

### 6.1 Adjacency as an Access Path

Adjacency represents **direct hypergraph traversal**.

Properties:

* Role-aware
* Directional
* Snapshot-consistent

Adjacency access paths are bound to `Expand`-class physical operators (RFC-0008).

---

### 6.2 Adjacency Guarantees

Adjacency access paths MUST guarantee:

* Completeness for declared roles
* Correct directionality
* Stable role binding within a `SnapshotId`

Adjacency MUST NOT:

* Implicitly filter
* Change traversal semantics
* Drop hyperedges

---

### 6.3 Hypergraph Arity

Adjacency structures MUST declare supported hyperedge arities.

Hypergraph adjacency MAY support:

* Binary projection
* Role-based projection
* Full arity preservation

---

## 7. Planner Visibility and Eligibility

### 7.1 Discovery

The planner MUST be able to deterministically query:

* Available indexes
* Supported predicates
* Declared guarantees
* Applicable entities

---

### 7.2 Eligibility Rules

An index or adjacency path is eligible iff:

* Predicate semantics match declared guarantees
* Predicate is deterministic
* The access path declares snapshot consistency compatible with RFC-0012

Approximate access paths MUST NOT be selected unless explicitly permitted.

---

## 8. Rewrite Interaction

Rewrite rules (RFC-0006) MAY:

* Replace `Scan + Filter` with index-backed access
* Fuse `Expand` with adjacency access
* Reorder predicates to improve eligibility

Rewrites MUST NOT:

* Introduce index-dependent semantics
* Assume ordering unless guaranteed

**Note**: Index usage does not imply a distinct physical operator; it is a specialization of Scan operators unless otherwise specified.

---

## 9. Execution Binding

### 9.1 Binding Time

Access paths are bound during **physical planning**.

Logical plans remain index-agnostic.

---

### 9.2 Execution Access

During execution:

* Access paths are invoked via physical operators
* Storage is accessed exclusively via `ExecutionContextTrait::storage()`
* All reads observe the execution `SnapshotId`

This preserves RFC-0012 storage invariants.

---

## 10. Backend Considerations

### 10.1 Local Execution

* Value and composite indexes preferred
* Adjacency favored for binary traversal
* Vector indexes permitted with explicit cost penalties

### 10.2 Ray Distributed Execution

* Fragment-aligned indexes preferred
* Adjacency may induce shuffle
* Vector indexes executed with distributed scoring

Execution semantics remain identical across runtimes.

---

## 11. Approximate Access Paths

Approximate access paths:

* MUST declare approximation
* MUST be opt-in
* MUST NOT be used for correctness-critical predicates

Approximate results MUST be surfaced explicitly.

---

## 12. Explainability and Diagnostics

`EXPLAIN` MUST surface:

* Considered access paths
* Selected access paths
* Rejection reasons
* Adjacency usage

This requirement is mandatory.

---

## 13. Relationship to Other RFCs

* **RFC-0012**: Storage abstractions and snapshot semantics
* **RFC-0102**: Execution architecture and operator model
* **RFC-0008**: Physical operators binding access paths
* **RFC-0006**: Rewrite rules
* **RFC-0007**: Cost model

RFC-0009 defines **how data is reached**, not how it is processed.

---

## 14. Summary

Indexes and adjacency are **pure accelerators**:

* Semantically neutral
* Planner-visible
* Execution-bound
* Snapshot-consistent

This RFC completes the contract between **storage layout**, **planning**, and **execution**.
