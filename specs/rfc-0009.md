# RFC-0009: Indexes, Adjacency & Access Paths

**Status**: Draft
**Authors**: Grism Team
**Created**: 2026-01-21
**Last Updated**: 2026-01-21
**Depends on**: RFC-0002, RFC-0006, RFC-0007, RFC-0008
**Supersedes**: —

---

## 1. Abstract

This RFC defines the **indexing, adjacency, and access path model** for Grism.

Indexes and adjacency structures are **semantic accelerators**: they do not change query meaning, but they radically change execution cost and feasibility. This document specifies:

* Index types and guarantees
* Adjacency as a first-class access path
* Planner visibility and eligibility rules
* Rewrite and execution constraints

This RFC is the **bridge between storage layout and logical semantics**.

---

## 2. Scope and Non-Goals

### 2.1 Scope

This RFC specifies:

* Logical index abstractions
* Adjacency structures and semantics
* Access path contracts
* Planner–executor interaction
* Index eligibility rules

### 2.2 Non-Goals

This RFC does **not** define:

* Physical index implementations
* Storage file formats
* Index maintenance protocols
* Transaction or concurrency control
* Statistics collection (see RFC-0007)

---

## 3. Design Principles

1. **Semantics First**
   Indexes MUST NOT change logical results.

2. **Explicit Guarantees**
   Every index declares what it guarantees—and nothing more.

3. **Adjacency Is Not Relational Composition**
   Adjacency is a distinct semantic primitive for hyperedge traversal.

4. **Planner Visibility**
   The planner MUST know what access paths exist.

---

## 4. Access Path Model

### 4.1 Access Path Definition

An **Access Path** is a logical method for retrieving data satisfying a constraint.

Examples:

* Full scan
* Predicate index scan
* Adjacency traversal
* Vector similarity search

Access paths are **not operators**; they are execution strategies.

---

### 4.2 Access Path Guarantees

Each access path MUST declare:

* Covered columns
* Ordering guarantees (if any)
* Cardinality constraints
* Determinism
* Completeness (exact vs approximate)

---

## 5. Index Model

### 5.1 Logical Index Definition

A logical index is defined by:

```
Index {
  name
  indexed_entity
  indexed_columns
  index_type
  guarantees
}
```

Indexes are **read-only** from the planner's perspective.

### 5.2 Structural Indexes (Per Architecture Section 11.1)

| Index            | Description                              |
| ---------------- | ---------------------------------------- |
| **AdjacencyIndex** | Binary adjacency for arity=2 hyperedges  |
| **RoleIndex**      | Role-based indexes for n-ary hyperedges |
| **LabelIndex**     | Label and type bitmaps                   |

---

### 5.3 Index Types

#### 5.3.1 Value Index

Supports equality and range predicates.

Guarantees:

* Exact match semantics
* No false positives

---

#### 5.3.2 Composite Index

Indexes multiple columns.

Guarantees:

* Prefix matching
* Column order significance

---

#### 5.3.3 Full-Text Index

Supports text search predicates.

Guarantees:

* Approximate or exact (declared)
* Scoring support optional

---

#### 5.3.4 Vector Index

Supports similarity search.

Guarantees:

* Metric space consistency
* Approximate vs exact explicitly declared
* Top-K retrieval semantics

Vector indexes MUST declare recall guarantees.

### 5.4 Vector Indexes (Per Architecture Section 11.2)

| Index            | Description                              |
| ---------------- | ---------------------------------------- |
| **VectorIndex**   | Lance ANN indexes, HNSW structures       |

Vector indexes integrate directly with expression evaluation (e.g., `sim()` function).

---

## 6. Adjacency Model

### 6.1 Adjacency as First-Class Access Path

Adjacency represents **direct topological access**, not a join.

Properties:

* Role-aware
* Directional
* Bounded fan-out

Adjacency access paths are tied to `Expand` operators (RFC-0008).

---

### 6.2 Adjacency Guarantees

Adjacency access paths MUST guarantee:

* Completeness for specified roles
* Correct directionality
* Stable role binding

Adjacency MUST NOT:

* Filter implicitly
* Reorder semantics
* Drop hyperedges

---

### 6.3 Hypergraph Adjacency

Hyperedges introduce:

* Multi-role adjacency
* Role projection
* Arity preservation

Adjacency paths MUST declare supported arities.

---

## 7. Planner Visibility & Selection

### 7.1 Index Discovery

Planners MUST be able to query:

* Available indexes
* Supported predicates
* Coverage and guarantees

Index discovery MUST be deterministic.

---

### 7.2 Eligibility Rules

An index is **eligible** iff:

* Predicate matches index capabilities
* Predicate is deterministic (RFC-0003)
* Predicate semantics align with guarantees

Approximate indexes MUST NOT be used unless explicitly allowed.

---

## 8. Rewrite Interaction

Rewrite rules (RFC-0006) MAY:

* Replace Scan + Filter with IndexScan
* Fuse Expand with adjacency access
* Reorder predicates to maximize index usage

Rewrites MUST NOT:

* Introduce index-dependent semantics
* Assume ordering unless guaranteed

---

## 9. Execution Binding

### 9.1 Binding Time

Index selection occurs during **physical planning**.

Rules:

* Logical plan remains index-agnostic
* Physical plan binds access paths

---

### 9.2 Fallback Behavior

If an index becomes unavailable:

* Planner MUST fall back to scan
* Semantics MUST remain unchanged
* Cost MAY increase

---

## 10. Access Paths & Execution Backends

### 10.1 LocalExecutor (Relational)

* Value and composite indexes preferred
* Adjacency used when beneficial for binary hyperedges
* Vector indexes allowed with penalties

### 10.2 LocalExecutor (Adjacency)

* Adjacency REQUIRED for binary Expand operators
* AdjacencyIndex and RoleIndex preferred
* Label-based indexes for filtering

### 10.3 RayExecutor (Distributed)

* Partition-aware indexes preferred
* Cross-partition adjacency via shuffle
* Vector indexes with distributed scoring

### 10.4 Hybrid Strategy

* Mixed access paths allowed
* Adjacency + index fusion permitted
* Backend-specific optimization per subplan

---

## 11. Approximate Index Semantics

Approximate indexes (e.g. ANN):

Rules:

* MUST declare approximation
* MUST NOT be used for correctness-critical predicates
* MUST be explicitly opt-in

Approximate results MUST be labeled as such.

---

## 12. Explainability & Diagnostics

EXPLAIN MUST show:

* Which indexes were considered
* Which were chosen
* Why others were rejected
* Adjacency usage rationale

This is **mandatory**.

---

## 13. Error Handling

Index-related errors:

| Error              | Meaning               |
| ------------------ | --------------------- |
| IndexIneligible    | Predicate mismatch    |
| IndexUnavailable   | Index missing         |
| GuaranteeViolation | Index contract broken |

Errors MUST surface before execution.

---

## 14. Relationship to Other RFCs

* **RFC-0002**: Logical operators using adjacency
* **RFC-0006**: Rewrites enabling index usage
* **RFC-0007**: Cost model prefers access paths
* **RFC-0008**: Physical operators bind indexes
* **RFC-0012**: Storage layout (future)

RFC-0009 defines **how data is reached, not how it is processed**.

---

## 15. Open Questions

* Dynamic index selection
* Multi-index intersection
* Learned adjacency pruning
* Incremental index maintenance

---

## 16. Conclusion

This RFC formalizes **how Hypergraph touches data**.

> **Indexes accelerate predicates.
> Adjacency accelerates hyperedge traversal.
> Access paths accelerate execution—without altering truth.**
