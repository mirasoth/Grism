# RFC-0012: Storage & Persistence Layer

**Status**: Draft
**Authors**: Grism Team
**Created**: 2026-01-21
**Last Updated**: 2026-01-21
**Depends on**: RFC-0002, RFC-0008, RFC-0009, RFC-0011
**Supersedes**: —

---

## 1. Abstract

This RFC defines the **storage and persistence layer** for Grism.

The storage layer is responsible for:

* Durable persistence of Hypergraphs
* Efficient columnar and adjacency access
* Snapshot-consistent reads
* Index and adjacency materialization

This RFC specifies *what guarantees storage must provide* and *what execution may safely assume*, without prescribing a specific file format or engine.

---

## 2. Scope and Non-Goals

### 2.1 Scope

This RFC specifies:

* Persistent data model
* Storage abstractions and contracts
* Snapshot and versioning semantics
* Adjacency and index materialization
* Storage–execution interaction

### 2.2 Non-Goals

This RFC does **not** define:

* Transaction isolation levels beyond snapshot reads
* Write concurrency control
* Compaction algorithms
* Cloud object store semantics
* Backup and replication policy

---

## 3. Design Principles

1. **Columnar Is the Default**
   Storage MUST be column-oriented.

2. **Graph Is a Projection, Not a Format**
   Graph semantics emerge from projections, not bespoke layouts.

3. **Snapshot Consistency**
   Queries observe a stable snapshot.

4. **Separation of Truth and Acceleration**
   Indexes and adjacency are derived, not authoritative.

---

## 4. Persistent Data Model

### 4.1 Hypergraph Persistence

A persisted Hypergraph uses Lance dataset layout as defined in architecture (Section 10):

```
/datasets/
  nodes.lance
  hyperedges.lance
  properties.lance
  embeddings.lance
```

Logical separation is maintained between:
* **Structural data** (nodes, hyperedges, roles)
* **Attribute data** (properties)
* **Vector data** (embeddings)

Each Lance dataset MUST have:
* Stable Arrow schema
* Version identifier (MVCC)
* Immutable content within a version

---

### 4.2 Physical Schema Mapping

Logical types (RFC-0003) map to physical storage types.

Rules:

* Mapping MUST be deterministic
* Lossless conversion required
* Nullability preserved

Embedding and tensor types MUST be stored in a format compatible with vector indexing.

---

## 5. Storage Abstractions

### 5.1 Storage Units

Storage is organized into immutable **Lance fragments**.

Properties:

* Append-only writes
* Arrow column-aligned
* Independently addressable
* Snapshot-isolated (MVCC)

Fragments are the unit of:

* Scanning
* Caching
* Compaction
* Distribution

---

### 5.2 Storage Interface (Normative)

Conceptual interface using Lance:

```
LanceStorage {
  open_dataset(path)
  scan(schema, predicate, projection, snapshot)
  get_fragment_metadata()
  resolve_snapshot(version)
}
```

Storage MUST NOT:

* Execute expressions
* Apply logical rewrites
* Perform relational composition (via Expand)

---

## 6. Snapshot & Versioning Model

### 6.1 Snapshot Semantics

All reads operate on a **snapshot**.

Guarantees:

* Read-your-snapshot consistency
* No partial visibility
* Deterministic results

Snapshots MAY be:

* Time-based
* Version-based
* Explicitly pinned

---

### 6.2 Version Evolution

Versions are:

* Immutable
* Monotonically increasing
* Lineage-tracked

Old versions MAY be garbage-collected after safety windows.

---

## 7. Adjacency Materialization

### 7.1 Adjacency Storage

Adjacency is materialized as **derived structures** from base data.

Rules:

* Derived from authoritative edge / hyperedge tables
* Role-aware
* Direction-aware

Adjacency materialization MUST be:

* Rebuildable
* Version-aligned

---

### 7.2 Adjacency Layouts

Permitted layouts include:

* CSR / CSC
* Columnar adjacency lists
* Role-partitioned adjacency tables

Layout choice is storage-defined but MUST honor RFC-0009 guarantees.

---

## 8. Index Materialization

### 8.1 Index Persistence

Indexes are persisted separately from base data.

Rules:

* Indexes reference a specific snapshot
* Index rebuild does not change snapshot semantics
* Index invalidation is explicit

---

### 8.2 Index–Storage Interaction

Storage MUST expose:

* Index coverage
* Index version
* Index consistency status

Execution MUST:

* Fall back if index is stale or unavailable
* Never observe partial index state

---

## 9. Vector & AI-Native Storage

### 9.1 Embedding Storage

Embeddings MUST:

* Preserve dimensionality
* Support contiguous access
* Be indexable

Compression is allowed but MUST be lossless unless explicitly declared.

---

### 9.2 Tensor Storage

Tensor storage MAY:

* Use chunked layouts
* Support partial reads

Tensor semantics are opaque to storage.

---

## 10. Storage & Execution Interaction

### 10.1 Pushdown Capabilities

Storage MAY support:

* Predicate pushdown
* Projection pushdown
* Limit pushdown

Capabilities MUST be declared explicitly.

---

### 10.2 Scan Guarantees

Storage scans MUST guarantee:

* Completeness
* Deterministic ordering within a segment (optional)
* Schema stability

---

## 11. Failure & Corruption Handling

Storage MUST:

* Detect corruption
* Fail fast on inconsistency
* Never return partial or silently incorrect data

Recovery procedures are implementation-defined.

---

## 12. Observability & Diagnostics

Storage MUST expose:

* Segment statistics
* Scan performance metrics
* Cache hit rates
* Index usage statistics

These MUST be visible in EXPLAIN ANALYZE.

---

## 13. Relationship to Other RFCs

* **RFC-0008**: Physical operators consume storage scans
* **RFC-0009**: Indexes and adjacency depend on storage
* **RFC-0010**: Distributed execution relies on snapshot semantics
* **RFC-0011**: Runtime enforces backpressure over storage scans
* **RFC-0013**: Semantic layer builds on persisted data (future)

RFC-0012 defines **where truth lives**.

---

## 14. Open Questions

* Incremental adjacency maintenance
* Tiered storage (hot / cold)
* Storage-aware scheduling
* Cross-version query semantics

---

## 15. Conclusion

This RFC defines the **foundation of trust** for Grism.

> **Logic defines truth.
> Execution defines speed.
> Lance-based storage defines persistent memory.**
