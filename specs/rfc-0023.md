# RFC-0023: Index Materialization Semantics

**Status**: Draft
**Authors**: Grism Team
**Created**: 2026-01-23
**Last Updated**: 2026-01-23
**Depends on**: RFC-0009, RFC-0012, RFC-0018, RFC-0022, RFC-0102
**Supersedes**: —

---

## 1. Abstract

This RFC defines the **index materialization semantics** for Grism.

It specifies when, how, and under what guarantees indices are constructed as part of the **write and snapshot publication pipeline**, and how indices relate to adjacency layouts defined in RFC-0009.

Indices are treated as **derived, snapshot-bound artifacts**, never as mutable or authoritative state.

---

## 2. Scope and Non-Goals

### 2.1 Scope

This RFC specifies:

* Index lifecycle and ownership
* Index materialization timing
* Snapshot and fragment binding rules
* Planner-visible guarantees

### 2.2 Non-Goals

This RFC does **not** define:

* Specific index data structures (e.g., B-tree, hash)
* Query planning heuristics
* User-facing index definition syntax
* Runtime index mutation

---

## 3. Design Principles

### 3.1 Indices as Derived Structures

All indices in Grism are **derived from base datasets**:

* Node datasets
* Hyperedge datasets
* Adjacency datasets

No index is ever authoritative.

---

### 3.2 Snapshot-Bound Immutability

An index is always bound to exactly one snapshot.

Published indices are immutable and MUST NOT be updated in-place.

---

### 3.3 Write-Time Materialization

Indices are materialized during the **Materialize** phase defined in RFC-0022.

There is no lazy or read-time index creation.

---

## 4. Index Taxonomy

Grism supports three logical classes of indices:

1. **Property Indices** – accelerate predicate evaluation
2. **Adjacency Indices** – accelerate graph traversal
3. **Structural Indices** – accelerate fragment discovery and pruning

This RFC defines semantics common to all classes.

---

## 5. Index Lifecycle

Indices follow the same lifecycle as adjacency:

```
Begin → Mutate → Materialize → Publish
```

Indices are invisible until snapshot publication.

---

## 6. Materialization Semantics

### 6.1 Materialization Inputs

Index materialization consumes:

* Base datasets (nodes, hyperedges)
* Adjacency datasets (RFC-0009, RFC-0018)
* Fragment metadata

Indices MUST be derivable deterministically from these inputs.

---

### 6.2 Determinism

Given identical inputs, index materialization MUST produce byte-identical logical results.

Backend-specific physical encodings MAY differ.

---

### 6.3 Ordering and Stability

Index entries MUST be ordered deterministically.

Ordering rules MUST be documented by the backend.

---

## 7. Index–Adjacency Relationship

Adjacency datasets are the **primary access path** for graph traversal.

Indices MAY:

* Reference adjacency fragment boundaries
* Accelerate anchor-to-fragment resolution
* Provide role- or label-specific projections

Indices MUST NOT duplicate adjacency semantics.

---

## 8. Fragment Binding

Each index fragment is bound to:

```
(snapshot_id, base_fragment_id)
```

Rules:

* Index fragments align with base fragment boundaries where possible
* Fragment misalignment MUST be declared explicitly in metadata

---

## 9. Index Metadata

Each index exposes metadata:

```
IndexMeta {
  snapshot_id: SnapshotId,
  index_type: IndexType,
  target: IndexTarget,
  fragment_binding: Vec<FragmentBinding>,
  capabilities: IndexCaps
}
```

Metadata is planner-visible and immutable.

---

## 10. Backend-Specific Considerations

### 10.1 In-Memory Backend

* Indices MAY be ephemeral structures
* Index metadata MUST still be exposed

---

### 10.2 Local Lance Backend

* Indices MAY be stored as Lance datasets
* Index fragments map to Lance fragments

---

### 10.3 Cloud / ObjectStore Lance Backend

* Indices are stored as object-store datasets
* Publication requires the same coordination as base snapshots

---

## 11. Visibility and Failure Semantics

* Indices are visible only after snapshot publication
* Partial index materialization MUST NOT be observable
* Failed index builds invalidate the snapshot publication

---

## 12. Planner Guarantees

Planners MAY assume:

* Indices are complete for the snapshot
* Index metadata accurately describes coverage
* No index changes during execution

Planners MUST tolerate missing indices.

---

## 13. Guarantees

This RFC guarantees:

1. Snapshot-consistent index views
2. Deterministic index construction
3. Clear separation between base data and indices
4. Planner-visible index capabilities

---

## 14. Relationship to Other RFCs

* **RFC-0009**: Adjacency and access paths
* **RFC-0012**: Storage abstractions
* **RFC-0018**: Persistent layout
* **RFC-0022**: Write & mutation semantics
* **RFC-0019 / 0020 / 0021**: Storage backends
* **RFC-0102**: Execution engine architecture

RFC-0023 defines the **index contract shared across all backends**.

---

## 15. Summary

Index materialization in Grism:

* Occurs at write time
* Is snapshot-bound and immutable
* Is derived from adjacency and base data
* Exposes explicit metadata to planners

This RFC completes the write-path semantics for Grism storage.
