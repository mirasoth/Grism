# RFC-0024: Physical Planning Rules

**Status**: Draft
**Authors**: Grism Team
**Created**: 2026-01-23
**Last Updated**: 2026-01-23
**Depends on**: RFC-0009, RFC-0012, RFC-0018, RFC-0022, RFC-0023, RFC-0102
**Supersedes**: —

---

## 1. Abstract

This RFC defines the **physical planning rules** for Grism.

It specifies how logical plans are transformed into **backend-aware, fragment-oriented physical plans** using metadata exposed by storage, adjacency, and index layers.

Physical planning is strictly separated from execution and does not assume any specific runtime (local or distributed).

---

## 2. Scope and Non-Goals

### 2.1 Scope

This RFC specifies:

* Physical plan construction rules
* Use of fragment, adjacency, and index metadata
* Backend capability–aware plan selection
* Plan stability and determinism guarantees

### 2.2 Non-Goals

This RFC does **not** define:

* Logical query rewriting
* Cost models or statistics collection
* Runtime scheduling or parallelism mechanics
* Backend-specific operator implementations

---

## 3. Design Principles

### 3.1 Metadata-Driven Planning

All physical planning decisions MUST be derived from explicit metadata:

* `FragmentMeta`
* `AdjacencyFragmentMeta`
* `IndexMeta`
* `StorageCaps`

No implicit backend assumptions are permitted.

---

### 3.2 Fragment-First Execution Model

Physical plans are constructed in terms of **fragments**, not global datasets.

Fragments are the unit of:

* Pruning
* Parallelism
* Data movement

---

### 3.3 Capability-Gated Optimization

Optimizations MUST be gated by declared backend capabilities.

If a capability is absent, planners MUST fall back to a semantically correct plan.

---

## 4. Physical Plan Model

A physical plan is a tree of executable operators with associated properties, as defined in RFC-0102:

```
PhysicalPlan {
  root: PhysicalOperator,
  properties: PlanProperties
}

PlanProperties {
  execution_mode: ExecutionMode,
  partitioning: PartitioningSpec,
  blocking: bool
}
```

Each `PhysicalOperator` is parameterized by fragment references and metadata, and references its children via the `children()` method.

Physical plans are logically DAGs when considering data flow, but structurally trees rooted at the final output operator.

---

## 5. Fragment Selection Rules

### 5.1 Base Fragment Discovery

For each logical scan:

1. Enumerate candidate fragments via `FragmentMeta`
2. Apply fragment pruning predicates
3. Produce a fragment set for physical planning

---

### 5.2 Deterministic Ordering

Fragments MUST be ordered deterministically within a plan.

Ordering rules MUST be stable across runs.

---

## 6. Adjacency Planning Rules

### 6.1 Adjacency as Primary Traversal Primitive

Graph traversals MUST be planned using adjacency datasets, not edge scans.

Adjacency selection rules:

1. Prefer materialized adjacency matching traversal direction
2. Prefer adjacency with tighter fragment bindings
3. Prefer adjacency with declared role projections

---

### 6.2 Anchor-Driven Expansion

Traversal operators expand from **anchor fragments** defined by adjacency metadata.

Anchor ordering determines traversal order.

---

## 7. Index Utilization Rules

### 7.1 Optional Acceleration

Indices MAY be used to:

* Reduce fragment search space
* Accelerate anchor resolution
* Filter adjacency inputs

Absence of indices MUST NOT block planning.

---

### 7.2 Index–Fragment Alignment

Indices aligned with fragment boundaries SHOULD be preferred.

Misaligned indices incur additional merge or filter operators.

---

## 8. Join and Composition Rules

### 8.1 Fragment-Local Joins

Joins SHOULD be planned fragment-locally where possible.

Cross-fragment joins MUST be explicit in the plan.

---

### 8.2 Ordering Preservation

Fragment ordering MUST be preserved across joins unless explicitly reordered.

---

## 9. Backend-Specific Constraints

### 9.1 In-Memory Backend

* Favor batch-local operators
* Avoid excessive fragmentation

---

### 9.2 Local Lance Backend

* Exploit predicate and projection pushdown
* Align operators with Lance fragment boundaries

---

### 9.3 Cloud / ObjectStore Backend

* Favor fragment-sequential access
* Minimize cross-fragment fan-out
* Prefer larger fragment granularity

---

## 10. Plan Stability and Reproducibility

Given identical:

* Logical plan
* Snapshot
* Metadata

Physical planning MUST produce structurally equivalent plans.

---

## 11. Failure Semantics

Planning failures MUST:

* Be deterministic
* Fail before execution
* Leave no partial execution artifacts

---

## 12. Guarantees

This RFC guarantees:

1. Backend-agnostic physical planning
2. Fragment-aware optimization
3. Deterministic and reproducible plans
4. Clean separation between planning and execution

---

## 13. Relationship to Other RFCs

* **RFC-0009**: Adjacency and access paths
* **RFC-0012**: Storage abstractions
* **RFC-0018**: Persistent layout
* **RFC-0022**: Write & mutation semantics
* **RFC-0023**: Index materialization semantics
* **RFC-0102**: Execution engine architecture

RFC-0024 defines how these layers are **composed into executable plans**.

---

## 14. Summary

Physical planning in Grism:

* Is metadata-driven
* Operates on fragments and adjacency
* Respects backend capabilities
* Produces deterministic, execution-ready physical plans

This RFC completes the planning layer of Grism.
