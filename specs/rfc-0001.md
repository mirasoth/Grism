# RFC-0001: HyperGraph Logical Model and Execution Architecture

**Status**: Draft
**Authors**: HyperGraph / Grism Team
**Last Updated**: 2026-01-21

---

## 1. Abstract

This RFC specifies the **HyperGraph** data model and its execution architecture. HyperGraph is a hypergraph-first logical abstraction designed to unify expressive n-ary relational semantics with low-latency interactive graph queries and scalable graph computation. The document defines the core invariants, execution projections, physical layouts, and planning rules that enable Cypher compatibility without sacrificing hypergraph correctness.

---

## 2. Background & Motivation

Existing graph systems fall into two categories:

1. **Property graph systems** (e.g., Neo4j):

   * Optimized for traversal and interactive latency
   * Restricted to binary edges
   * Poor support for higher-order semantics

2. **Relational / hypergraph systems**:

   * Expressive and semantically complete
   * Require heavy joins for traversal
   * Unsuitable for interactive workloads

AI-native systems require *both*:

* Higher-order relational expressiveness (events, groups, symbolic reasoning)
* Sub-100ms interactive exploration and scalable graph computation

HyperGraph is introduced to resolve this tension.

---

## 3. Goals and Non-Goals

### 3.1 Goals

* Provide a **hypergraph-first logical model**
* Preserve **full semantic correctness** for n-ary relations
* Support **Cypher / GQL compatibility** as a projection
* Enable **low-latency interactive queries**
* Support **graph algorithms and AI workloads** efficiently
* Use a **single source of truth** with multiple execution strategies

### 3.2 Non-Goals

* Replacing Cypher or GQL standards
* Encoding all semantics purely in adjacency structures
* Providing a single execution engine for all workloads
* Optimizing derived graph projections for semantic correctness

---

## 4. Core Abstraction: HyperGraph

### 4.1 Definition

**HyperGraph** is the canonical logical data model.

> HyperGraph is a hypergraph-backed, relationally-executable, AI-native graph container.

It plays a role analogous to `DataFrame` in tabular systems.

### 4.2 Conceptual Mapping

| Tabular Systems | HyperGraph            |
| --------------- | --------------------- |
| Row             | Hyperedge             |
| Column          | Role / Attribute      |
| Join            | Hyperedge composition |
| Filter          | Sub-hypergraph        |

### 4.3 Invariants

1. HyperGraph is the **only source of truth**
2. Hyperedges may have **arbitrary arity**
3. Execution strategies must not alter semantics
4. All physical representations are **derived projections**

---

## 5. Language Compatibility Model

### 5.1 Cypher / GQL Compatibility

Cypher assumes a binary property graph. HyperGraph generalizes this via *projection*:

* Hyperedges with arity = 2 are mapped directly to property graph edges
* Hyperedges with arity > 2 are represented via node–hyperedge–node incidence patterns

Compatibility is provided as a **view**, not a core constraint.

### 5.2 Native Hypergraph Queries

HyperGraph may expose a native hypergraph query language (e.g., AnkQL) that operates directly on n-ary relations without projection.

---

## 6. The Join Problem

Executing HyperGraph queries purely via relational joins is:

* Semantically correct
* Computationally expensive
* Unsuitable for interactive traversal

Observation:

> Hypergraphs require set algebra; interactive graph queries require pointer chasing.

This necessitates multiple execution strategies.

---

## 7. Execution Architecture Overview

HyperGraph uses a **single logical model with multiple physical execution backends**.

| Workload                 | Execution Strategy   |
| ------------------------ | -------------------- |
| Interactive traversal    | Adjacency projection |
| Complex relational logic | Relational joins     |
| Graph algorithms         | Message passing      |

Joins are treated as a fallback mechanism.

---

## 8. Adjacency as a Projection

Adjacency structures do **not** define semantics.

> Adjacency is an index. HyperGraph is the model.

Multiple adjacency projections may coexist.

---

## 9. Adjacency Projections

### 9.1 Incidence Adjacency (Lossless)

**Node ↔ Hyperedge** adjacency:

* Fully represents arbitrary hypergraphs
* Preserves roles and arity
* Requires two-hop traversal

This projection guarantees correctness.

### 9.2 Binary Adjacency (Fast Path)

**Node ↔ Node** adjacency for arity = 2 hyperedges:

* CSR-like layout
* Enables pointer-chasing traversal
* Used for Cypher compatibility and interactive queries

### 9.3 Derived Adjacency (Approximate)

Clique or star expansions for higher-arity hyperedges:

* Enable graph algorithms
* Semantically approximate
* Never used for correctness-sensitive queries

---

## 10. Physical Layout: Binary Adjacency

### 10.1 Node Dictionary

* `node_id` (dense, u64)
* labels
* properties

### 10.2 Edge Dictionary (Binary Only)

* `edge_id`
* `edge_type`
* `src_node_id`
* `dst_node_id`
* properties

### 10.3 Adjacency Lists

CSR-style layout:

* `adj_out`: node → edge slice
* `adj_out_edges`: (edge_id, dst_node_id, edge_type)
* optional `adj_in` for reverse traversal

All stored as append-only, snapshot-isolated Lance files.

---

## 11. Query Planning & Rewrite Rules

### 11.1 Planning Pipeline

```
Query AST (Cypher / AnkQL)
  → HyperGraph Logical Plan
    → Cost-Based Rewrite
      → Physical Execution Plan
```

### 11.2 Join Elision Rules

Use adjacency when:

* Hyperedge arity == 2
* No hyperedge-level predicates
* Traversal is anchored or LIMIT-bounded

Otherwise, fall back to relational execution.

---

## 12. Execution Modes

HyperGraph supports explicit or inferred execution modes:

| Mode        | Objective   | Backend         |
| ----------- | ----------- | --------------- |
| interactive | low latency | adjacency       |
| relational  | correctness | joins           |
| graph       | throughput  | message passing |

---

## 13. Graph Computation Model

Graph algorithms do not execute via joins.

Execution flow:

1. Select appropriate adjacency projection
2. Extract compact edge lists
3. Execute message-passing algorithms
4. Optionally persist results as new hyperedges

---

## 14. Distribution & Scalability

* Partition data by `node_id` ranges
* Each shard owns adjacency and node slices
* Cross-shard traversal via async RPC
* Ray may be used as the orchestration layer

---

## 15. Caching & Consistency

* L1: in-memory hot adjacency slices
* L2: memory-mapped Lance files
* L3: compiled query plans

All reads are snapshot-consistent via MVCC.

---

## 16. Open Questions

* Cost model calibration for mixed workloads
* Materialization thresholds for derived adjacencies
* Incremental maintenance of incidence adjacency
* Formal semantics for path counting over hyperedges

---

## 17. Conclusion

HyperGraph establishes a clean separation between **semantic correctness** and **execution efficiency**. By treating adjacency as a derived index and preserving hypergraphs as the logical truth, the system achieves interactive performance, expressive power, and AI-native extensibility within a single coherent architecture.

---

## 18. References (Informative)

* Property Graph Model and Cypher
* Hypergraph Theory
* Columnar Storage (Lance)
* Graph Processing Systems (Neo4j, TigerGraph)
