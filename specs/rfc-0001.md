# RFC-0001: Hypergraph Logical Model and Execution Architecture

**Status**: Frozen
**Authors**: Grism Team
**Last Updated**: 2026-01-21

---

## 1. Abstract

This RFC specifies the **Hypergraph** logical model and its execution architecture. Hypergraph is a hypergraph-first logical abstraction designed to unify expressive n-ary relational semantics with low-latency interactive graph queries and scalable graph computation. The document defines the core invariants, execution projections, physical layouts, and planning rules that enable Cypher compatibility without sacrificing hypergraph correctness.

---

## 2. Background & Motivation

Existing graph systems fall into two categories:

1. **Property graph systems** (e.g., Neo4j):

   * Optimized for traversal and interactive latency
   * Restricted to binary edges
   * Poor support for higher-order semantics

2. **Relational / hypergraph systems**:

   * Expressive and semantically complete
   * Require heavy relational execution for traversal
   * Unsuitable for interactive workloads

AI-native systems require *both*:

* Higher-order relational expressiveness (events, groups, symbolic reasoning)
* Sub-100ms interactive exploration and scalable graph computation

Hypergraph is introduced to resolve this tension.

---

## 3. Goals and Non-Goals

### 3.1 Goals

* Provide a **hypergraph-first logical model**
* Preserve **full semantic correctness** for n-ary relations
* Support **Cypher / GQL compatibility** as a projection
* Enable **low-latency interactive queries**
* Support **graph algorithms and AI workloads** efficiently
* Use a **single source of truth** with multiple execution strategies

### 3.2 Non-Goals

* Replacing Cypher or GQL standards
* Encoding all semantics purely in adjacency structures
* Providing a single execution engine for all workloads
* Optimizing derived graph projections for semantic correctness

---

## 4. Core Abstraction: Hypergraph

### 4.1 Definition

**Hypergraph** is the canonical logical data model.

> Hypergraph is a hypergraph-backed, relationally-executable, AI-native graph container.

It plays a role analogous to `DataFrame` in tabular systems and aligns with the **Hypergraph** abstraction defined in the architecture design (Section 4).

### 4.2 Conceptual Mapping

| Tabular Systems | Hypergraph            |
| --------------- | --------------------- |
| Row             | Hyperedge             |
| Column          | Role / Property       |
| Composition     | Hyperedge composition |
| Filter          | Sub-hypergraph        |

### 4.3 Invariants

1. Hypergraph is the **only source of truth**
2. Hyperedges may have **arbitrary arity** (arity ≥ 2)
3. Execution strategies must not alter semantics
4. All physical representations are **derived projections**

---

## 5. Frame System Integration

The Hypergraph model exposes data through **Frames**, which are immutable, lazy, logical views as defined in the architecture design (Section 3.2).

| Frame Type         | Semantics                                         |
| ------------------ | ------------------------------------------------- |
| **NodeFrame**      | A view over nodes matching a label and predicate |
| **HyperedgeFrame** | A view over hyperedges with arbitrary arity      |
| **EdgeFrame**      | A binary projection of `HyperedgeFrame`          |

All operations return Frames that compile into logical plans over the canonical hyperedge representation.

---

## 6. Language Compatibility Model

### 6.1 Cypher / GQL Compatibility

Cypher assumes a binary property graph. Hypergraph generalizes this via *projection*:

* Hyperedges with arity = 2 are mapped directly to property graph edges
* Hyperedges with arity > 2 are represented via node–hyperedge–node incidence patterns

Compatibility is provided as a **view**, not a core constraint.

### 6.2 Native Hypergraph Queries

Hypergraph may expose a native hypergraph query language (e.g., AnkQL) that operates directly on n-ary relations without projection.

---

## 7. The Relational Execution Challenge

Executing Hypergraph queries purely via relational operations is:

* Semantically correct
* Computationally expensive
* Unsuitable for interactive traversal

Observation:

> Hypergraphs require set algebra; interactive graph queries require pointer chasing.

This necessitates multiple execution strategies.

---

## 8. Execution Architecture Overview

Hypergraph uses a **single logical model with multiple physical execution backends** as defined in the architecture design (Section 9).

| Workload                 | Execution Backend      | Strategy               |
| ------------------------ | ---------------------- | ---------------------- |
| Interactive traversal    | LocalExecutor          | Adjacency projection   |
| Complex relational logic | LocalExecutor/RayExecutor | Relational execution |
| Graph algorithms         | RayExecutor            | Message passing        |

Relational execution is treated as a fallback mechanism through the **Expand** logical operator.

---

## 9. Adjacency as a Projection

Adjacency structures do **not** define semantics.

> Adjacency is an index. Hypergraph is the model.

Multiple adjacency projections may coexist.

---

## 10. Adjacency Projections

### 10.1 Incidence Adjacency (Lossless)

**Node ↔ Hyperedge** adjacency:

* Fully represents arbitrary hypergraphs
* Preserves roles and arity
* Requires two-hop traversal

This projection guarantees correctness.

### 10.2 Binary Adjacency (Fast Path)

**Node ↔ Node** adjacency for arity = 2 hyperedges:

* CSR-like layout
* Enables pointer-chasing traversal
* Used for Cypher compatibility and interactive queries

### 10.3 Derived Adjacency (Approximate)

Clique or star expansions for higher-arity hyperedges:

* Enable graph algorithms
* Semantically approximate
* Never used for correctness-sensitive queries

---

## 11. Physical Layout: Binary Adjacency

### 11.1 Node Dictionary

* `node_id` (dense, u64)
* labels
* properties

### 11.2 Edge Dictionary (Binary Only)

* `edge_id`
* `edge_type`
* `src_node_id`
* `dst_node_id`
* properties

### 11.3 Adjacency Lists

CSR-style layout:

* `adj_out`: node → edge slice
* `adj_out_edges`: (edge_id, dst_node_id, edge_type)
* optional `adj_in` for reverse traversal

All stored as append-only, snapshot-isolated Lance files.

---

## 12. Query Planning & Rewrite Rules

### 12.1 Planning Pipeline

```
Query AST (Cypher / AnkQL)
  → Hypergraph Logical Plan
    → Cost-Based Rewrite
      → Physical Execution Plan
```

### 12.2 Expand Optimization Rules

The **Expand** operator is the dominant traversal mechanism. Optimization rules:

* **BinaryExpand** mode: Use adjacency when hyperedge arity = 2
* **RoleExpand** mode: Use role-based relational execution for n-ary hyperedges
* **Predicate pushdown**: Push filters before Expand when possible
* **MaterializeHyperedge**: Only materialize hyperedges when required

Binary adjacency is preferred for interactive workloads; n-ary relational execution is used for semantic completeness.

---

## 13. Execution Modes

Hypergraph supports explicit or inferred execution modes:

| Mode        | Objective   | Backend         |
| ----------- | ----------- | --------------- |
| interactive | low latency | adjacency       |
| relational  | correctness | relational execution |
| graph       | throughput  | message passing |

---

## 14. Graph Computation Model

Graph algorithms do not execute via relational operations.

Execution flow:

1. Select appropriate adjacency projection
2. Extract compact edge lists
3. Execute message-passing algorithms
4. Optionally persist results as new hyperedges

---

## 15. Distribution & Scalability

* Partition data by `node_id` ranges
* Each shard owns adjacency and node slices
* Cross-shard traversal via async RPC
* Ray may be used as the orchestration layer

---

## 16. Caching & Consistency

* L1: in-memory hot adjacency slices
* L2: memory-mapped Lance files
* L3: compiled query plans

All reads are snapshot-consistent via MVCC.

---

## 17. Open Questions

* Cost model calibration for mixed workloads
* Materialization thresholds for derived adjacencies
* Incremental maintenance of incidence adjacency
* Formal semantics for path counting over hyperedges

---

## 18. Conclusion

Hypergraph establishes a clean separation between **semantic correctness** and **execution efficiency**. By treating adjacency as a derived index and preserving hypergraphs as the logical truth, the system achieves interactive performance, expressive power, and AI-native extensibility within a single coherent architecture.

---

## 19. References (Informative)

* Property Graph Model and Cypher
* Hypergraph Theory
* Columnar Storage (Lance)
* Graph Processing Systems (Neo4j, TigerGraph)
