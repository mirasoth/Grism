# RFC-0015: Schema, Typing & Evolution

**Status**: Draft
**Authors**: Grism Team
**Created**: 2026-01-21
**Last Updated**: 2026-01-23
**Depends on**: RFC-0002, RFC-0003, RFC-0012, RFC-0013
**Supersedes**: —

---

## 1. Abstract

This RFC defines the **schema, typing, and evolution model** for Grism.

Grism is designed as a **long-lived cognitive system**, not a transient database. In such systems, **schemas evolve continuously**:

* New properties are introduced as understanding deepens
* Types are refined as reasoning layers mature
* Modal representations (e.g., embeddings, images, video features) change over time
* Symbolic abstractions emerge atop raw data

This RFC establishes that **schemas are explicit, typed, versioned, evolvable, and queryable — but never brittle**.

---

## 2. Scope and Non-Goals

### 2.1 Scope

This RFC specifies:

* The schema model for nodes, hyperedges, and modalities
* The relationship between schema and the expression/type system
* Formal schema evolution rules and compatibility guarantees
* How schemas interact with planning, storage, and reasoning layers

### 2.2 Non-Goals

This RFC does **not** define:

* Enforcing rigid relational normalization
* Fully ACID transactional schema migration
* Application-level ontology management (covered in RFC-0013)

---

## 3. Design Principles

1. **Typed by default, flexible by design**
2. **Schema evolution without global rewrites**
3. **Query-time and plan-time type safety**
4. **Schema awareness across symbolic and neural layers**
5. **Minimal impedance with Lance's columnar evolution model**
6. **Preserve historical meaning across schema versions**

---

## 3. Schema Model Overview

### 3.1 Schema as First-Class Metadata

In Grism, schemas are **first-class objects** stored and versioned alongside data.

A schema defines:

* Entity kinds (NodeType, EdgeType, HyperedgeType)
* Property definitions
* Type constraints
* Optional semantic annotations
* Modal payload contracts

Schemas are:

* Addressable by `(schema_id, version)`
* Immutable once published
* Append-only across versions

---

### 3.2 Core Schema Entities

#### 3.2.1 Node Schema

```text
NodeSchema {
  name: Symbol
  version: SchemaVersion
  properties: Map<PropertyName, PropertySchema>
  labels: Set<Symbol>
  annotations: Map<Symbol, Value>
}
```

#### 3.2.2 Hyperedge Schema

```text
HyperedgeSchema {
  name: Symbol
  version: SchemaVersion
  roles: Map<RoleName, NodeTypeRef>
  cardinality: Map<RoleName, Cardinality>
  properties: Map<PropertyName, PropertySchema>
  annotations: Map<Symbol, Value>
}
```

Hyperedges explicitly encode **role semantics**, enabling reasoning and planning beyond pairwise edges.

---

### 3.3 Property Schema

```text
PropertySchema {
  name: Symbol
  type: Type
  nullable: Bool
  default: Optional<Value>
  annotations: Map<Symbol, Value>
}
```

Property types reference the **global type system** defined in RFC-0003.

---

## 4. Type System Integration

### 4.1 Schema Types vs Expression Types

Schemas define **structural types**.
Expressions operate on **value types**.

Example:

```cypher
MATCH (p:Person)
WHERE p.age > 30
RETURN p.name
```

* `p.age` is typed via `PropertySchema`
* Expression typing is validated at **logical planning time**
* Runtime enforcement may be relaxed depending on execution mode

---

### 4.2 Structural Subtyping

Schema evolution relies on **structural subtyping**:

* Adding a nullable property → **subtype**
* Widening a property type (e.g., `Int → Float`) → **subtype**
* Removing a property → **breaking**

Schemas form a **directed acyclic graph** of versions.

---

## 5. Schema Versioning

### 5.1 Version Identity

Each schema has:

* Stable `schema_id`
* Monotonic `version`

Versions are immutable.

---

### 5.2 Compatibility Classes

Each schema change is classified as:

| Change Type               | Compatibility       |
| ------------------------- | ------------------- |
| Add nullable property     | Backward compatible |
| Add property with default | Backward compatible |
| Widen type                | Backward compatible |
| Add annotation            | Compatible          |
| Remove property           | Breaking            |
| Narrow type               | Breaking            |
| Change role cardinality   | Breaking            |

Compatibility is machine-checked.

---

### 5.3 Multi-Version Coexistence

Grism **never rewrites historical data** by default.

Queries may:

* Bind to a specific schema version
* Operate over multiple versions
* Use compatibility projection rules

---

## 6. Schema Evolution Semantics

### 6.1 Logical Projection Across Versions

When querying across schema versions:

* Missing properties evaluate to `NULL`
* Default values may be injected at query time
* Type widening is implicit
* Type narrowing requires explicit cast

---

### 6.2 Storage Implications

* Lance columns are append-only
* New properties map to new columns
* Missing columns are interpreted as NULL vectors
* No physical rewrite required for most evolutions

---

## 7. Modal Schema Extensions

Schemas may define **modal payload contracts**:

```text
ModalSchema {
  modality: ModalityType   // image, video, audio, embedding
  encoding: EncodingType
  shape: Optional<Shape>
  semantic_role: Optional<Symbol>
}
```

Example:

* An `Image` property may later gain an `Embedding` property
* Both are schema-linked but physically distinct

---

## 8. Schema & Reasoning Interaction

### 8.1 Semantic Annotations

Schemas may carry semantic hints:

```text
annotations:
  owl:Class = Person
  reasoning:closed_world = false
```

These annotations:

* Do not affect storage
* Inform symbolic reasoning (RFC-0013)
* Enable schema-aware inference

---

### 8.2 Derived Schema Views

Reasoning may produce **derived facts** that conform to:

* An existing schema
* Or a derived virtual schema

Derived schemas are:

* Versioned
* Read-only
* Traceable via provenance

---

## 9. Schema Validation & Enforcement Levels

Grism supports **configurable enforcement**:

| Level         | Behavior                     |
| ------------- | ---------------------------- |
| Strict        | Reject non-conforming writes |
| Lenient       | Coerce or nullify            |
| Deferred      | Validate at query time       |
| Observational | Log violations only          |

Enforcement level is per-dataset or per-session.

---

## 10. Planner & Optimizer Interaction

* Logical planner uses schema types for validation
* Rewrite rules may exploit schema constraints
* Cost model may leverage property density and nullability
* Execution engine receives fully typed plans

Schema mismatches never crash execution; they degrade gracefully.

---

## 11. Introspection & Tooling

Schemas are queryable:

```cypher
SHOW SCHEMA Person@v3
SHOW SCHEMA HISTORY Person
```

Schema metadata is exposed to:

* Python APIs
* Planner debugging tools
* Visualization layers

---

## 12. Open Questions

1. Should schema compatibility be transitive or stepwise?
2. How far can automatic coercion go before meaning is lost?
3. Should modal schema evolution support learned adapters?

---

## 14. Conclusion

This RFC establishes schemas in Grism as:

* **Typed but flexible**
* **Versioned but non-blocking**
* **Structural, semantic, and modal**
* **Integrated across planning, storage, and reasoning**

> **Schemas in Grism do not constrain thought —
> they preserve meaning across time.**
