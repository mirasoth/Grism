# RFC-0017: Transactions, Mutations & Write Semantics

**Status**: Draft
**Stage**: Core Engine
**Authors**: Grism Core Team
**Created**: 2026-01-21
**Last Updated**: 2026-01-23
**Depends on**: RFC-0002, RFC-0003, RFC-0012, RFC-0015, RFC-0016
**Supersedes**: —

---

## 1. Motivation

Grism is designed for **long-running, evolving knowledge systems**, where:

* Data is ingested incrementally
* Agents and humans both perform writes
* Inferred facts coexist with asserted facts
* Storage is append-only and columnar

Traditional transactional models assume:

* Mutable rows
* Immediate consistency
* Centralized coordination

These assumptions conflict with Grism’s design.

This RFC defines a **transaction and mutation model** that:

* Preserves correctness and traceability
* Works naturally with append-only storage
* Supports partial, deferred, and speculative writes
* Makes write semantics explicit and inspectable

---

## 2. Design Goals

1. **Append-only, snapshot-based semantics**
2. **Explicit write intent and provenance**
3. **Composable mutation operations**
4. **Isolation without global locking**
5. **Compatibility with schema evolution and constraints**
6. **Graceful handling of conflicts**

Non-Goals:

* Full serializable ACID transactions
* In-place record mutation
* Global synchronous constraint enforcement

---

## 3. Conceptual Model

### 3.1 Transactions as Snapshot-Bound Write Sets

A **transaction** in Grism is:

> A **bounded set of mutations** applied atomically to produce a new snapshot.

Transactions are:

* Immutable once committed
* Identified by `txn_id`
* Associated with a base snapshot

---

### 3.2 Snapshots

Snapshots represent **logical database states**.

Each snapshot:

* References parent snapshot(s)
* Includes a set of committed transactions
* Is immutable
* Can be queried directly

Snapshots form a **DAG**, not necessarily a linear chain.

---

## 4. Mutation Primitives

All writes are expressed as **explicit mutation primitives**.

### 4.1 Insert

```text
InsertNode {
  node_id
  schema_ref
  properties
}
```

* Adds a new entity
* Properties validated against schema version
* Missing properties default to NULL or schema default

---

### 4.2 InsertEdge / InsertHyperedge

* Validates role bindings
* Cardinality constraints may be deferred
* Referential constraints may be weak or strong

---

### 4.3 Update (Logical)

Grism does **not** mutate records in place.

An update is:

> Insert a new version that supersedes an older one.

```text
UpdateNode {
  target_id
  changes
  supersedes: previous_version
}
```

---

### 4.4 Delete (Logical Retraction)

Deletes are **logical retractions**, not physical removal.

```text
Retract {
  target_id
  reason
}
```

Retracted entities remain:

* Queryable historically
* Visible to provenance tracking

---

## 5. Write Semantics

### 5.1 Visibility Rules

* Writes are invisible until transaction commit
* All mutations in a transaction appear atomically
* Readers always see a consistent snapshot

---

### 5.2 Isolation Levels

Grism supports **snapshot isolation** by default.

Optional modes:

* Read-your-writes (session-scoped)
* Monotonic reads
* Best-effort serial ordering (advisory)

No blocking read locks are required.

---

## 6. Constraint Interaction

* Constraints are evaluated per RFC-0016
* Strict constraints may abort a transaction
* Deferred constraints produce post-commit violations
* Violations are attached to the transaction

A transaction may commit **with known violations**, depending on policy.

---

## 7. Conflict Detection & Resolution

### 7.1 Conflict Model

Conflicts arise when:

* Two transactions modify the same logical entity
* Referential assumptions are invalidated
* Schema versions diverge

---

### 7.2 Resolution Strategies

Configurable per dataset:

| Strategy           | Behavior              |
| ------------------ | --------------------- |
| Last-write-wins    | Default               |
| Versioned-merge    | Keep all versions     |
| Reject-on-conflict | Abort transaction     |
| Agent-mediated     | Defer to repair agent |

---

## 8. Provenance & Attribution

Every mutation records:

* Author (human / agent / system)
* Timestamp
* Source (sensor, inference, user)
* Confidence (optional)

This integrates with provenance tracking (future RFC).

---

## 9. Schema Evolution & Writes

* Writes bind to a specific schema version
* Mixed-schema writes are allowed in a single transaction
* Queries reconcile versions via projection rules

Schema mismatches never corrupt data; they produce explicit annotations.

---

## 10. Physical Storage Mapping

* Each transaction appends new fragments to Lance datasets
* Retractions are stored as tombstone vectors
* No in-place mutation occurs
* Compaction is an offline optimization

---

## 11. Distributed Writes

* Transactions may be coordinated locally or via a distributed manager
* Two-phase commit is **not required**
* Conflicts resolved post-hoc
* Snapshot graph reconciled asynchronously

---

## 12. Failure Semantics

* Failed transactions leave no partial state
* Partial ingestion produces aborted transaction records
* Crashes do not corrupt committed snapshots

---

## 13. Introspection & Tooling

Transactions are queryable:

```cypher
SHOW TRANSACTION tx123
SHOW SNAPSHOT HISTORY
```

This enables:

* Debugging
* Replay
* Audit trails

---

## 14. Open Questions

1. Should transactions support savepoints?
2. How to expose speculative writes to agents?
3. When to compact tombstones safely?

---

## 15. Summary

This RFC establishes Grism’s write model as:

* **Append-only and snapshot-based**
* **Explicit in intent and provenance**
* **Compatible with evolving schemas**
* **Resilient to partial inconsistency**
* **Designed for autonomous agents**

> In Grism, writing is not overwriting truth —
> it is **adding another layer of understanding**.
