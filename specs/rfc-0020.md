# RFC-0020: In-Memory Storage Backend

**Status**: Draft
**Authors**: Grism Team
**Created**: 2026-01-23
**Last Updated**: 2026-01-23
**Depends on**: RFC-0009, RFC-0012, RFC-0018, RFC-0102
**Supersedes**: —

---

## 1. Abstract

This RFC defines the **in-memory storage backend** for Grism.

The in-memory backend provides a **non-persistent, low-latency** implementation of the storage interface defined in RFC-0012, while fully conforming to the persistent layout and adjacency semantics defined in RFC-0018.

This backend is intended for:

* Testing and validation
* Interactive exploration and prototyping
* Small-scale or ephemeral workloads
* As a reference implementation for storage semantics

---

## 2. Scope and Non-Goals

### 2.1 Scope

This RFC specifies:

* In-memory realization of nodes, hyperedges, and adjacency layouts
* Fragment and snapshot semantics in memory
* Capability exposure for the in-memory backend

### 2.2 Non-Goals

This RFC does **not** define:

* Persistence guarantees
* Durability or recovery semantics
* Distributed or shared-memory execution
* Thread-safety or concurrency policies

---

## 3. Design Principles

### 3.1 Semantic Equivalence with Persistent Backends

The in-memory backend MUST be semantically equivalent to persistent backends with respect to:

* Snapshot isolation
* Fragment boundaries
* Adjacency visibility and access paths

Differences are permitted only in performance characteristics and durability.

---

### 3.2 Explicit Snapshot Ownership

Snapshots in the in-memory backend are **explicit objects** owned by the runtime.

No implicit global state is permitted.

---

### 3.3 Zero Persistence Assumptions

All data lives entirely in memory.

Implementations MUST NOT assume filesystem, object storage, or external services.

---

## 4. Memory Layout Overview

The in-memory backend organizes storage as a hierarchy of runtime objects:

```
MemoryStorage
 └── Snapshot
     ├── NodeStore
     ├── HyperedgeStore
     └── AdjacencyStore
```

Each component mirrors the conceptual layout defined in RFC-0018.

---

## 5. Node Storage

### 5.1 Representation

Nodes are stored in columnar form using Arrow-compatible buffers:

```
NodeStore {
  schema: ArrowSchema,
  batches: Vec<RecordBatch>
}
```

Node IDs are dense and snapshot-local.

---

## 6. Hyperedge Storage

### 6.1 Representation

Hyperedges are stored similarly to nodes, without adjacency materialization:

```
HyperedgeStore {
  schema: ArrowSchema,
  batches: Vec<RecordBatch>
}
```

Hyperedges contain arity and role descriptors as properties.

---

## 7. Adjacency Storage

### 7.1 Representation

Adjacency is materialized explicitly in memory:

```
AdjacencyStore {
  adjacency_sets: Map<AdjacencySpec, AdjacencySet>
}
```

Each `AdjacencySet` corresponds to a single adjacency specification.

---

### 7.2 AdjacencySet Layout

```
AdjacencySet {
  schema: ArrowSchema,
  batches: Vec<RecordBatch>,
  fragment_meta: Vec<AdjacencyFragmentMeta>
}
```

Rows follow the same logical schema as persistent adjacency datasets.

---

### 7.3 Fragment Semantics

Adjacency fragments are explicit logical partitions over batches.

Fragment boundaries are stable for the lifetime of a snapshot.

---

## 8. Fragment and Snapshot Semantics

### 8.1 Fragment Mapping

| Grism Concept | In-Memory Concept |
| ------------- | ----------------- |
| FragmentMeta  | Batch slice       |
| SnapshotId    | Snapshot object   |

Fragments are immutable once exposed.

---

### 8.2 Snapshot Resolution

`Storage::resolve_snapshot()` returns a handle to a snapshot object.

Snapshots are not globally registered unless explicitly stored by the runtime.

---

## 9. Storage Capabilities

The in-memory backend advertises the following capabilities:

```
StorageCaps {
  predicate_pushdown: false,
  projection_pushdown: true,
  fragment_pruning: true,
  object_store: false,
}
```

Adjacency capabilities mirror those of persistent backends, except where explicitly unsupported.

---

## 10. Scan Semantics

All scans:

* Return Arrow `RecordBatch` streams
* Are pull-based
* Respect snapshot isolation

Predicate evaluation is performed in-memory by the execution engine.

---

## 11. Planner and Execution Interaction

Planners and executors interact with the in-memory backend exclusively through:

* `Storage::scan()`
* Fragment and adjacency metadata

No backend-specific assumptions are permitted.

---

## 12. Guarantees

This RFC guarantees:

1. Full compliance with RFC-0012 storage contracts
2. Snapshot and fragment semantic equivalence with persistent backends
3. Explicit and inspectable adjacency materialization
4. Minimal overhead and low-latency access

---

## 13. Relationship to Other RFCs

* **RFC-0012**: Storage abstractions
* **RFC-0018**: Persistent storage & adjacency layout
* **RFC-0019**: Lance-based local storage backend
* **RFC-0009**: Adjacency and access paths
* **RFC-0102**: Execution engine architecture

RFC-0020 defines a **non-persistent sibling backend** to RFC-0019.

---

## 14. Summary

The in-memory storage backend provides:

* A lightweight, fast storage implementation
* Semantic parity with persistent backends
* A clean reference model for storage behavior

It is intended as both a development tool and a correctness oracle for other storage backends.
