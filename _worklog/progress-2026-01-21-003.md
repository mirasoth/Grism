---
date: 2026-01-21
session: python-api-impl-003
objective: Implement Python API module with expression lowering to Rust LogicalPlan
status: completed
---

## Objective

Implement the Python API in `src/python/` module with:
- Full expression system with lowering to Rust LogicalExpr
- Frame types (NodeFrame, EdgeFrame, HyperedgeFrame) with logical plan building
- Aggregation support via GroupedFrame
- Unit tests for the API

## Completed

1. **PyExpr with Expression Lowering**
   - Implemented `ExprKind` internal representation
   - Full lowering to `grism_logical::LogicalExpr`
   - Binary operations: comparison (==, !=, <, >, <=, >=), arithmetic (+, -, *, /, %), logical (&, |, ~)
   - Unary operations: is_null, is_not_null, negation
   - String functions: contains, starts_with, ends_with, like, matches, lower, upper, trim, replace, substring, split, concat, length
   - Math functions: abs, ceil, floor, round, sqrt, power
   - Date/time functions: year, month, day, date
   - Graph functions: labels, type, id, properties, nodes, relationships, path_length
   - Conditional: coalesce, if_

2. **PyAggExpr with Aggregation Functions**
   - count, count_distinct
   - sum, avg, min, max
   - collect, collect_distinct
   - first, last

3. **PyNodeFrame with Logical Plan Building**
   - filter/where: builds FilterOp with predicate expression
   - select: builds ProjectOp with column expressions
   - with_column: adds computed column
   - expand: builds ExpandOp with direction, hops, aliases
   - optional_expand: placeholder for outer join semantics
   - order_by/sort: builds SortOp with sort keys
   - limit/offset/skip/head: builds LimitOp
   - distinct: placeholder
   - group_by/groupby: creates PyGroupedFrame
   - collect: execution placeholder
   - explain: returns plan tree string

4. **PyEdgeFrame**
   - filter: builds FilterOp
   - source/target/endpoints: expands to connected nodes
   - limit/collect/explain

5. **PyHyperedgeFrame**
   - filter: builds FilterOp
   - where_role: filters by role binding
   - expand: role-based expansion to nodes
   - roles: returns role names (placeholder)
   - limit/collect/explain

6. **PyGroupedFrame**
   - agg: applies aggregations with named/positional arguments
   - count: convenience for COUNT(*)

7. **Executor Classes**
   - PyExecutor: factory for local/ray executors
   - PyLocalExecutor: local execution config
   - PyRayExecutor: distributed execution config

## Files Changed

| File | Change |
|------|--------|
| `src/python/expressions.rs` | Complete rewrite with expression IR and lowering |
| `src/python/hypergraph.rs` | Complete rewrite with frame types and plan building |
| `src/python/executor.rs` | Fixed attribute macros and signatures |
| `src/python/mod.rs` | Updated exports and function registrations |
| `src/common/config/src/lib.rs` | Added pyclass attribute for Python feature |

## Tests

- All Rust unit tests pass: 72 tests in grism-logical and grism-core
- Python tests require Python development libraries (not available in build environment)

## Key Implementation Details

### Expression Lowering

Python expressions are represented internally as `ExprKind` which can be:
- Column references (with optional qualifier)
- Literals
- Binary/Unary operations
- Function calls
- Aggregates
- Sort keys

The `to_logical_expr()` method converts to `grism_logical::LogicalExpr`, mapping:
- Column names to `LogicalExpr::Column` or `LogicalExpr::QualifiedColumn`
- Binary ops to `LogicalExpr::Binary` with `BinaryOp`
- Functions to `LogicalExpr::Function` with `FuncExpr`
- Aggregates to `LogicalExpr::Aggregate` with `AggExpr`

### Plan Building

Frame operations chain to build logical operator trees:
```
hg.nodes("Person")           → Scan(Node, label=Person)
  .filter(col("age") > 18)   → Filter(predicate)
  .expand("KNOWS")           → Expand(BINARY, edge=KNOWS)
  .select("name", "email")   → Project(name, email)
  .limit(10)                 → Limit(10)
```

Each Frame stores its current `LogicalOp` and operations return new frames with extended plans.

## Notes

- PyO3 version 0.22.6 requires careful handling of `Bound` types
- Default values in `#[pyo3(signature)]` must match Rust types exactly
- `Vec<&Bound>` is not valid - must use `Vec<Bound>` for varargs
- Python feature requires Python development libraries for testing

## Next Steps

- Add Python tests when environment has Python dev libs
- Implement actual execution in collect() methods
- Add schema introspection methods
- Implement transaction support
